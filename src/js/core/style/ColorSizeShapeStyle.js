//@ts-check

import { Style } from "../Style"
import { Cell } from "../Dataset"
import { Viewer } from "../viewer/viewer";
import * as CONSTANTS from "../constants.js";
import { Points, Color, Float32BufferAttribute, BufferGeometry, ShaderMaterial, } from "three";
import * as Utils from "../utils/utils";

/**
 * A very generic style that shows grid cells with specific color, size and shape.
 * It can be used to show variables as cell colors, cell size, cell shape, or any combination of the three visual variables.
 * 
 * @author Julien Gaffuri
 */
export class ColorSizeShapeStyle extends Style {

    /**
      * @param {function} color A function returning the color of the cell.
      * @param {function} size A function returning the size of a cell (in geographical unit).
      * @param {function} shape A function returning the shape of a cell.
      */
    constructor(color = () => "#EA6BAC", size = null, shape = () => "square") {
        super()

        /** @type {function} */
        this.color = color;

        /** @type {function} */
        this.size = size;

        /** @type {function} */
        this.shape = shape;
    }


    /**
     * Draw cells as squares, with various colors and size.
     * 
     * @param {Array.<Cell>} cells 
     * @param {number} resolution 
     * @param {Viewer} viewer 
     */
    draw(cells, resolution, viewer) {

        this.colors = [];
        this.positions = [];
        this.sizes = [];
        this.shapes = [];

        this.bufferGeometry = new BufferGeometry();

        //if size is used, sort cells by size so that the biggest are drawn first
        if (this.size)
            cells.sort((c1, c2) => (this.size(c2) - this.size(c1)));

        for (let cell of cells) {

            //position
            this.positions.push(cell.x, cell.y, CONSTANTS.point_z);

            //color
            let c = this.color ? new Color(this.color(cell)) : new Color("#EA6BAC");
            this.colors.push(c.r, c.g, c.b);
            cell.color = this.color(cell) || '#EA6BAC'; //save for tooltip

            //size - in ground meters
            this.sizes.push(this.size ? this.size(cell) : resolution);

            //shape
            if (this.shape) {
                const shape = this.shape(cell);
                if (shape == "square") {
                    this.shapes.push(1.0);
                } else if (shape == "circle") {
                    this.shapes.push(2.0);
                } else {
                    throw new Error('Unexpected shape:' + shape);
                }
            }
        }

        this.pointsMaterial = new ShaderMaterial({
            uniforms: {
                multiplier: {
                    value: 1000 //km TODO: define dynamically. This value needs to be adjusted according to screen in order prevent screen flickering when zooming
                }
            },
            fragmentShader: this.squareFragmentShader(), // TODO: make dynamic 
            vertexShader: this.vertexShader(),
            vertexColors: true
        });

        //set positions
        this.bufferGeometry.setAttribute("position", new Float32BufferAttribute(this.positions, 3));
        //set colors
        this.bufferGeometry.setAttribute("color", new Float32BufferAttribute(this.colors, 3));
        //set sizes
        this.bufferGeometry.setAttribute("size", new Float32BufferAttribute(this.sizes, 1));
        //set shapes
        if (this.shape) this.bufferGeometry.setAttribute("shape", new Float32BufferAttribute(this.shapes, 1));
        
        // create layer if new
        if (!this.threejsObject) {
            this.threejsObject = new Points(this.bufferGeometry, this.pointsMaterial);
            this.threejsObject.renderOrder = 1; //bottom
            viewer.scene.add(this.threejsObject);
        } else {
            // else update its attributes
            this.threejsObject.geometry = this.bufferGeometry;
            this.threejsObject.material = this.pointsMaterial;
        }
    }

    /**
    * @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
    * @function fragmentShader
    *  TODO: make fragment shader dynamic according to custom 'shape' attribute
    */ 
    fragmentShader() {
        return `
            varying vec3 vColor;
            varying float vShape;

            void main() {
                if (vShape === 1.0) {

                    //square
                    gl_FragColor = vec4( vColor.rgb, 1.0 );

                } 
                
                if (vShape === 2.0) {

                    //circle
                    float r = 0.0, delta = 0.0, alpha = 1.0;
                    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                    r = dot(cxy, cxy);
                    if (r > 1.0) {
                        discard;
                    }
                    gl_FragColor = vec4( vColor.rgb, 1.0 );
                    
                }
            }
        `;
    }

    /**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
    squareFragmentShader() {
        return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
    }

    /**
    * @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
    * @function fragmentShader
    */
    circleFragmentShader() {
        return `
        varying vec3 vColor;
        
        void main() {
            float r = 0.0, delta = 0.0, alpha = 1.0;
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            r = dot(cxy, cxy);
            if (r > 1.0) {
                discard;
            }
            gl_FragColor = vec4( vColor.rgb, 1.0 );
        }
    `;
    }

    /**
    * @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
    * @function vertexShader
    */
    vertexShader() {
        return `
      uniform float multiplier;
      attribute float size;
      attribute float shape;

      float scale;
      varying vec3 vColor;
      varying float vShape;
      
    
      void main() {
        // pass to fragment shader
        vColor = color;
        vShape = shape;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile & desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers & desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
    }

}
