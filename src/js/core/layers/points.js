// this file contains the logic for creating and updating threejs point layers (three.Points())
import {
    Points,
    Color,
    Float32BufferAttribute,
    BufferGeometry,
    ShaderMaterial,
    PointsMaterial,
    BoxBufferGeometry,
    MeshBasicMaterial,
    Object3D,
    Geometry,
    Mesh,
    Vector3
} from "three";
import * as CONSTANTS from "../constants.js";

/**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
function fragmentShader() {
    return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
}

/**
* @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
* @function vertexShader
*/
function vertexShader() {
    return `
      uniform float multiplier;
      attribute float size;
      float scale;
      varying vec3 vColor;
    
      void main() {
        vColor = color;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile & desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers & desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
}

/**
* @description create or update THREE.js viewer.pointsLayer layer. 
* At the moment, only ONE viewer.pointsLayer layer at a time is handled by the viewer, so a second call of gridviz.gridData() will overwrite the initial layer
* @function addPointsToScene
* @parameter points [{}]
*/
export function addPointsToScene(viewer, pointsArray) {


    if (viewer.cellShape_ == 'square') {
        //threejs recommends using BufferGeometry instead of Geometry for performance
        /*   indices = [0, 1, 2, 0, 2, 3];
      bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));  */
        if (!viewer.pointsGeometry) {
            viewer.pointsGeometry = new BufferGeometry();
        }

        let colors = [];
        let positions = [];
        let sizes = [];

        for (var i = 0; i < pointsArray.length; i++) {
            // Set vector coordinates from data
            let coords = [
                pointsArray[i].x,
                pointsArray[i].y
            ];
            let x = parseFloat(coords[0]);
            let y = parseFloat(coords[1]);
            let z = CONSTANTS.point_z;
            let indicator = pointsArray[i][viewer.colorField_];
            let hex = getCellColor(viewer, indicator);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);

            if (!isNaN(x) && !isNaN(y)) {
                positions.push(x, y, z);
                if (!isNaN(color.r) && !isNaN(color.g) && !isNaN(color.b)) {
                    colors.push(color.r, color.g, color.b);
                } else {
                    let blk = new Color("#000");
                    colors.push(blk.r, blk.g, blk.b)
                }
                if (viewer.sizeField_) {
                    sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
                } else {
                    sizes.push(viewer.pointSize);
                }
            }
        } //fin loop

        //set buffer geometry attributes
        viewer.pointsGeometry.setAttribute(
            "position",
            new Float32BufferAttribute(positions, 3)
        );
        viewer.pointsGeometry.setAttribute(
            "color",
            new Float32BufferAttribute(colors, 3)
        );
        //Variable point size will affect raycasting: https://github.com/mrdoob/three.js/issues/5105
        viewer.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
        viewer.pointsGeometry.computeBoundingSphere();
        //create or reuse viewer.pointsLayer Material
        if (!viewer.pointsMaterial) {
            // Apply custom point sizes, instead of using three.js pointsMaterial
            viewer.pointsMaterial = new ShaderMaterial({
                uniforms: {
                    multiplier: {
                        value: 1050 + (50 * window.devicePixelRatio) //km TODO: define dynamically. This value needsto be adjusted according to screen in order prevent white lines across the screen flickering when zooming
                    }
                },
                fragmentShader: fragmentShader(),
                vertexShader: vertexShader(),
                vertexColors: true
            });

            //use threejs PointsMaterial instead:
            // pointsMaterial = new PointsMaterial({
            //   size: gridConfig.pointSize * 2, // when using three.js attenuation we have to multiply the cellSize by 2
            //   sizeAttenuation: true,
            //   //https://github.com/mrdoob/three.js/blob/master/src/constants.js
            //   vertexColors: THREE.VertexColors
            // });

        } else {
            viewer.pointsMaterial.size = viewer.pointSize;
        }

        //create or overwrite viewer.pointsLayer object
        if (!viewer.pointsLayer) {
            viewer.pointsLayer = new Points(viewer.pointsGeometry, viewer.pointsMaterial);
            viewer.pointsLayer.renderOrder = 1; //bottom
            viewer.scene.add(viewer.pointsLayer);
        } else {
            //overwrite current la
            viewer.pointsLayer.geometry = viewer.pointsGeometry;
            viewer.pointsLayer.material = viewer.pointsMaterial;
        }

    } else if (viewer.cellShape_ == "bar") {

        // define bars object, geometry and material
        const bars = new Object3D();


        // create bar for each cell
        for (var i = 0; i < pointsArray.length; i++) {
            let height;

            if (viewer.sizeField_) {
                height = viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]);
            } else {
                height = viewer.pointSize;
            }

            let hex = getCellColor(viewer, pointsArray[i][viewer.colorField_]);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);
 
            let x = parseFloat(pointsArray[i].x);
            let y = parseFloat(pointsArray[i].y);
            
            const bar = getBar(x, y, viewer.pointSize, viewer.pointSize,height,color);
            bar.lookAt(new Vector3(x,y,0.0001));
            bars.add(bar);
        }

        // let x = 4369, y = 3230, z = 0.0001;
        // const bar = getBar(x, y, radius);
        // bar.lookAt(new Vector3(x,y,z));
        // bars.add(bar);

        // add bars to the viewer
        viewer.pointsLayer = bars;
        viewer.scene.add(bars);

    }

}

function getCellColor(viewer, value) {
    let hex = viewer.colorScaleFunction_(parseFloat(value)); //d3 scale-chromatic
    if (hex == "rgb(NaN, NaN, NaN)") {
        hex = "#000"; //fallback to black
    }
return hex;

}

function getBar(x, y,width,length, height, color) {


    const geometry = new BoxBufferGeometry(width,length, height);
    const material = new MeshBasicMaterial({ color: color });
    const bar = new Mesh(geometry, material);

    // const phi = (90 - lat) * Math.PI / 180;
    // const theta = (180 - lng) * Math.PI / 180;

    // bar.position.x = radius * Math.sin(phi) * Math.cos(theta);
    // bar.position.y = radius * Math.cos(phi);
    // bar.position.z = radius * Math.sin(phi) * Math.sin(theta);

    bar.position.x = x;
    bar.position.y = y;
    bar.position.z = 0.001 + (height/2);

    return bar;
}

/**
 * @description rebuilds array which stores point sizes
 * @function updatePointsSizes
 */
export function updatePointsSizes(viewer, pointsArray) {
    let sizes = [];
    for (var i = 0; i < pointsArray.length; i++) {
        if (viewer.sizeField_ && viewer.sizeField_ !== "null") {
            sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
        } else {
            sizes.push(viewer.pointSize);
        }
    }
    //update sizes
    viewer.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    viewer.pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = viewer.pointsGeometry;
}


/**
* @description rebuilds array of point colours
* @function updatePointsColors
*/
export function updatePointsColors(viewer, pointsArray) {
    let colors = [];
    for (var i = 0; i < pointsArray.length; i++) {
        let hex = viewer.colorScaleFunction_(pointsArray[i][viewer.colorField_]); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);
        if (color) colors.push(color.r, color.g, color.b);
    }
    //update colors
    viewer.pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    viewer.pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = viewer.pointsGeometry;
}


