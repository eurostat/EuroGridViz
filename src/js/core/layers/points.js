// this file contains the logic for creating and updating threejs point layers (three.Points())
import {
    Points,
    Color,
    Float32BufferAttribute,
    BufferGeometry,
    ShaderMaterial,
    PointsMaterial
} from "three";
import * as CONSTANTS from "../constants.js";

/**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
function fragmentShader() {
    return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
}

/**
* @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
* @function vertexShader
*/
function vertexShader() {
    return `
      uniform float multiplier;
      attribute float size;
      float scale;
      varying vec3 vColor;
    
      void main() {
        vColor = color;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile & desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers & desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
}

/**
* @description create or update THREE.js viewer.pointsLayer layer. 
* At the moment, only ONE viewer.pointsLayer layer at a time is handled by the viewer, so a second call of gridviz.gridData() will overwrite the initial layer
* @function addPointsToScene
* @parameter points [{}]
*/
export function addPointsToScene(viewer, pointsArray) {
    //threejs recommends using BufferGeometry instead of Geometry for performance
    /*   indices = [0, 1, 2, 0, 2, 3];
  bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));  */
    if (!viewer.pointsGeometry) {
        viewer.pointsGeometry = new BufferGeometry();
    }

    let colors = [];
    let positions = [];
    let sizes = [];

    for (var i = 0; i < pointsArray.length; i++) {
        // Set vector coordinates from data
        let coords = [
            pointsArray[i].x,
            pointsArray[i].y
        ];
        let x = parseFloat(coords[0]);
        let y = parseFloat(coords[1]);
        let z = CONSTANTS.point_z;
        let indicator = pointsArray[i][viewer.colorField_];
        let hex = viewer.colorScaleFunction_(parseFloat(indicator)); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);

        if (!isNaN(x) && !isNaN(y)) {
            positions.push(x, y, z);
            if (!isNaN(color.r) && !isNaN(color.g) && !isNaN(color.b)) {
                colors.push(color.r, color.g, color.b);
            } else {
                let blk = new Color("#000");
                colors.push(blk.r, blk.g, blk.b)
            }
            if (viewer.sizeField_) {
                sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
            } else {
                sizes.push(viewer.pointSize);
            }
        }
    } //fin loop

    //set buffer geometry attributes
    viewer.pointsGeometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
    );
    viewer.pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    //Variable point size will affect raycasting: https://github.com/mrdoob/three.js/issues/5105
    viewer.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    viewer.pointsGeometry.computeBoundingSphere();
    //create or reuse viewer.pointsLayer Material
    if (!viewer.pointsMaterial) {
        // Apply custom point sizes, instead of using three.js pointsMaterial
        viewer.pointsMaterial = new ShaderMaterial({
            uniforms: {
                multiplier: {
                    value: 1050 + (50 * window.devicePixelRatio) //km TODO: define dynamically. This value needsto be adjusted according to screen in order prevent white lines across the screen flickering when zooming
                }
            },
            fragmentShader: fragmentShader(),
            vertexShader: vertexShader(),
            vertexColors: true
        });

        //use threejs PointsMaterial instead:
        // pointsMaterial = new PointsMaterial({
        //   size: gridConfig.pointSize * 2, // when using three.js attenuation we have to multiply the cellSize by 2
        //   sizeAttenuation: true,
        //   //https://github.com/mrdoob/three.js/blob/master/src/constants.js
        //   vertexColors: THREE.VertexColors
        // });

    } else {
        viewer.pointsMaterial.size = viewer.pointSize;
    }
    //create or overwrite viewer.pointsLayer object
    if (!viewer.pointsLayer) {
        viewer.pointsLayer = new Points(viewer.pointsGeometry, viewer.pointsMaterial);
        viewer.pointsLayer.renderOrder = 1; //bottom
        viewer.scene.add(viewer.pointsLayer);
    } else {
        viewer.pointsLayer.geometry = viewer.pointsGeometry;
        viewer.pointsLayer.material = viewer.pointsMaterial;
    }
}


/**
 * @description rebuilds array which stores point sizes
 * @function updatePointsSizes
 */
export function updatePointsSizes(viewer, pointsArray) {
    let sizes = [];
    for (var i = 0; i < pointsArray.length; i++) {
        if (viewer.sizeField_ && viewer.sizeField_ !== "null") {
            sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
        } else {
            sizes.push(viewer.pointSize);
        }
    }
    //update sizes
    pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = pointsGeometry;
}


/**
* @description rebuilds array of point colours
* @function updatePointsColors
*/
export function updatePointsColors(viewer, pointsArray) {
    let colors = [];
    for (var i = 0; i < pointsArray.length; i++) {
        let hex = viewer.colorScaleFunction_(pointsArray[i][viewer.colorField_]); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);
        if (color) colors.push(color.r, color.g, color.b);
    }
    //update colors
    pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = pointsGeometry;
}