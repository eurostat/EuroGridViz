// this file contains the logic for creating and updating threejs point layers (three.Points())
import {
    Points,
    Color,
    Float32BufferAttribute,
    BufferGeometry,
    ShaderMaterial,
    PointsMaterial,
    BoxBufferGeometry,
    MeshBasicMaterial,
    Object3D,
    Geometry,
    Mesh,
    Vector3
} from "three";
import * as CONSTANTS from "../constants.js";

/**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
function fragmentShader() {
    return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
}

/**
* @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
* @function vertexShader
*/
function vertexShader() {
    return `
      uniform float multiplier;
      attribute float size;
      float scale;
      varying vec3 vColor;
    
      void main() {
        vColor = color;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile & desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers & desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
}

/**
* @description create or update THREE.js app.pointsLayer layer. 
* At the moment, only ONE app.pointsLayer layer at a time is handled by the app, so a second call of gridviz.gridData() will overwrite the initial layer
* @function addPointsToScene
* @parameter app
* @parameter grid: config passed to addGrid()
* @parameter pointsArray [{}]
*/
export function addPointsToScene(app, grid, pointsArray) {


    if (app.cellShape_ == 'square') {
        //threejs recommends using BufferGeometry instead of Geometry for performance
        /*   indices = [0, 1, 2, 0, 2, 3];
      bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));  */
        if (!app.pointsGeometry) {
            app.pointsGeometry = new BufferGeometry();
        }

        let colors = [];
        let positions = [];
        let sizes = [];

        for (var i = 0; i < pointsArray.length; i++) {
            // Set vector coordinates from data
            let coords = [
                pointsArray[i].x,
                pointsArray[i].y
            ];
            let x = parseFloat(coords[0]);
            let y = parseFloat(coords[1]);
            let z = CONSTANTS.point_z;
            let stat = pointsArray[i][grid.colorField];
            let hex = getCellColor(app, stat);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);

            if (!isNaN(x) && !isNaN(y)) {
                positions.push(x, y, z);
                if (!isNaN(color.r) && !isNaN(color.g) && !isNaN(color.b)) {
                    colors.push(color.r, color.g, color.b);
                } else {
                    let blk = new Color("#000");
                    colors.push(blk.r, blk.g, blk.b)
                }
                if (grid.sizeField) {
                    sizes.push(app.sizeScaleFunction_(pointsArray[i][grid.sizeField_]));
                } else {
                    sizes.push(grid.cellSize);
                }
            }
        } //fin loop

        //set buffer geometry attributes
        app.pointsGeometry.setAttribute(
            "position",
            new Float32BufferAttribute(positions, 3)
        );
        app.pointsGeometry.setAttribute(
            "color",
            new Float32BufferAttribute(colors, 3)
        );
        //Variable point size will affect raycasting: https://github.com/mrdoob/three.js/issues/5105
        app.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
        app.pointsGeometry.computeBoundingSphere();
        //create or reuse app.pointsLayer Material
        if (!app.pointsMaterial) {
            // Apply custom point sizes, instead of using three.js pointsMaterial
            app.pointsMaterial = new ShaderMaterial({
                uniforms: {
                    multiplier: {
                        value: 1000 //km TODO: define dynamically. This value needs to be adjusted according to screen in order prevent screen flickering when zooming
                    }
                },
                fragmentShader: fragmentShader(),
                vertexShader: vertexShader(),
                vertexColors: true
            });

            //use threejs PointsMaterial instead:
            // pointsMaterial = new PointsMaterial({
            //   size: grid.pointSize * 2, // when using three.js attenuation we have to multiply the cellSize by 2
            //   sizeAttenuation: true,
            //   //https://github.com/mrdoob/three.js/blob/master/src/constants.js
            //   vertexColors: THREE.VertexColors
            // });

        } else {
            app.pointsMaterial.size = grid.cellSize;
        }

        //create or overwrite app.pointsLayer object
        if (!app.pointsLayer) {
            app.pointsLayer = new Points(app.pointsGeometry, app.pointsMaterial);
            app.pointsLayer.renderOrder = 1; //bottom
            app.viewer.scene.add(app.pointsLayer);
        } else {
            //overwrite current la
            app.pointsLayer.geometry = app.pointsGeometry;
            app.pointsLayer.material = app.pointsMaterial;
        }

    } else if (app.cellShape_ == "bar") {

        // define bars object, geometry and material
        const bars = new Object3D();


        // create bar for each cell
        for (var i = 0; i < pointsArray.length; i++) {
            let height;

            if (grid.sizeField) {
                height = app.sizeScaleFunction_(pointsArray[i][grid.sizeField]);
            } else {
                height = grid.cellSize;
            }

            let hex = getCellColor(app, pointsArray[i][grid.colorField]);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);

            let x = parseFloat(pointsArray[i].x);
            let y = parseFloat(pointsArray[i].y);

            const bar = getBar(x, y, grid.cellSize, grid.cellSize, height, color);
            bar.lookAt(new Vector3(x, y, 0.0001));
            bars.add(bar);
        }

        // let x = 4369, y = 3230, z = 0.0001;
        // const bar = getBar(x, y, radius);
        // bar.lookAt(new Vector3(x,y,z));
        // bars.add(bar);

        // add bars to the app
        app.pointsLayer = bars;
        app.viewer.scene.add(bars);

    }

}

function getCellColor(app, value) {
    let hex = app.colorScaleFunction_(parseFloat(value)); //d3 scale-chromatic
    if (hex == "rgb(NaN, NaN, NaN)") {
        hex = "#000"; //fallback to black
    }
    return hex;

}

function getBar(x, y, width, length, height, color) {


    const geometry = new BoxBufferGeometry(width, length, height);
    const material = new MeshBasicMaterial({ color: color });
    const bar = new Mesh(geometry, material);

    // const phi = (90 - lat) * Math.PI / 180;
    // const theta = (180 - lng) * Math.PI / 180;

    // bar.position.x = radius * Math.sin(phi) * Math.cos(theta);
    // bar.position.y = radius * Math.cos(phi);
    // bar.position.z = radius * Math.sin(phi) * Math.sin(theta);

    bar.position.x = x;
    bar.position.y = y;
    bar.position.z = 0.001 + (height / 2);

    return bar;
}

/**
 * @description rebuilds array which stores point sizes
 * @function updatePointsSizes
 */
export function updatePointsSizes(app, pointsArray) {
    let sizes = [];
    for (var i = 0; i < pointsArray.length; i++) {
        if (grid.sizeField && grid.sizeField !== "null") {
            sizes.push(app.sizeScaleFunction_(pointsArray[i][grid.sizeField]));
        } else {
            sizes.push(app.currentResolution_);
        }
    }
    //update sizes
    app.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    app.pointsGeometry.computeBoundingSphere();
    app.pointsLayer.geometry = app.pointsGeometry;
}


/**
* @description rebuilds array of point colours
* @function updatePointsColors
*/
export function updatePointsColors(app, grid, pointsArray) {
    let colors = [];
    for (var i = 0; i < pointsArray.length; i++) {
        let hex = app.colorScaleFunction_(pointsArray[i][grid.colorField]); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);
        if (color) colors.push(color.r, color.g, color.b);
    }
    //update colors
    app.pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    app.pointsGeometry.computeBoundingSphere();
    app.pointsLayer.geometry = app.pointsGeometry;
}


