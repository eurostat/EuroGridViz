<!DOCTYPE html>
<html lang="en" style="height: 100%">

<head>
    <meta name="viewport" content="maximum-scale=1.0, user-scalable=no" />
    <title></title>
</head>

<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">
    <div id="viz-container" style="height: 100%; width: 100%"></div>

    <div style="
                font-size: 0.9em;
                position: absolute;
                left: 10px;
                top: 10px;
                width: auto;
                height: auto;
                padding: 5px;
                border: 0px;
                border-radius: 5px;
                background: #ffffffcc;
                line-height: 1.6;
                box-shadow: 3px 3px 3px grey, -3px -3px 3px #ddd;
            ">
        <span style="font-size: 1.3em; font-weight: bold">Population en France</span><br />
        <div id="layer">
            Année:
            <select id="year">
                <option value="2015">2015</option>
                <option value="2017">2017</option>
                <option value="2019" selected>2019</option>
            </select>
            <br />
            <input type="radio" name="layer" id="color" value="color" checked />
            <label for="color">Couleur</label>
            <br />
            <input type="radio" name="layer" id="colorDark" value="colorDark" />
            <label for="colorDark">Couleur sombre</label>
            <br />
            <input type="radio" name="layer" id="size" value="size" />
            <label for="size">Cercles proportionnels</label>
            <br />
            <input type="radio" name="layer" id="dots" value="dots" />
            <label for="dots">Nuage de points</label>
            <br />
            <input type="radio" name="layer" id="pillar" value="pillar" />
            <label for="pillar">Barres 3D</label>
            <br />
            <input type="radio" name="layer" id="joyplot" value="joyplot" />
            <label for="joyplot">Joyplot</label>
            <br />
            <input type="radio" name="layer" id="smoothed" value="smoothed" />
            <label for="smoothed">Lissage </label><input type="range" min="3" max="20" value="10" class="slider"
                id="sigmaTK" style="width: 100px" />
            <br />
            <span style="font-size: 1.3em; font-weight: bold">Changement</span>
            <br />
            <input type="radio" name="layer" id="colorCh" value="colorCh" />
            <label for="colorCh">Couleur</label>
            <br />
            <input type="radio" name="layer" id="colorChSmTK" value="colorChSmTK" />
            <label for="colorChSmTK">Lissage </label><input type="range" min="3" max="20" value="10" class="slider"
                id="sigmaCCH" style="width: 100px" />
            <br />
            <input type="radio" name="layer" id="sizeCh" value="sizeCh" />
            <label for="sizeCh">Cercles proportionnels</label>
            <br />
            <input type="radio" name="layer" id="segmentCh" value="segmentCh" />
            <label for="segmentCh">Segments</label>
        </div>
        <hr />
        Géo:
        <select id="geo">
            <option value="met" selected>France métropolitaine</option>
            <option value="reun">Réunion</option>
            <option value="mart">Martinique</option>
        </select>
        <br />
        <input type="checkbox" id="label" checked />
        <label for="label">Noms villes</label>
        <input type="checkbox" id="boundary" checked />
        <label for="boundary">Limites adm.</label>
        <hr />
        Source:
        <a href="https://www.insee.fr/fr/statistiques/7655515" target="_blank" rel="noopener noreferrer">INSEE -
            Filosofi - 200m</a>
    </div>

    <script src="../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@1.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-smoothing@1.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script>
        let containerDiv = document.getElementById('viz-container')

        const app = new gviz.App(containerDiv)
            .setZoomFactorExtent([10, 1500])
            .setViewFromURL()

        //load datasets, one per geo region
        const popDataset = {}
        const getDataset = (geo) =>
            app.makeMultiScaleTiledGridDataset(
                [200, 400, 1000, 2000, 5000, 10000, 20000, 50000],
                (r) =>
                    "https://raw.githubusercontent.com/jgaffuri/tiled-grid-france-filosofi/main/out/csv/" + geo + "/ts_ind/" +
                    r +
                    "m/",
                {
                    preprocess: (c) => {
                        /*/prepare change data
                        if (!c.Ind_2015 && !c.Ind_2017) c.d2015_2017 = 0
                        else if (!c.Ind_2015 && c.Ind_2017) c.d2015_2017 = +c.Ind_2017
                        else if (c.Ind_2015 && !c.Ind_2017) c.d2015_2017 = -c.Ind_2015
                        else c.d2015_2017 = c.Ind_2017 - c.Ind_2015
                        //ratio
                        c.p2011_2018 = c.Ind_2015 == 0 ? 999 : c.d2015_2017 / c.Ind_2015*/
                    },
                }
            )
        popDataset.met = getDataset("met")
        popDataset.reun = getDataset("reun")
        popDataset.mart = getDataset("mart")

        //default color
        const col = '#e54f37'

        //
        const update = () => {
            //read GUI selection
            const layCode = document.querySelector('input[name="layer"]:checked').value
            const year = "ind" + document.querySelector('#year').value
            const geo = document.querySelector('#geo').value

            //remove layers
            app.layers = []

            //tooltip functions
            const tooltipFun = (c, r) =>
                +c[year]
                    ? '<b>' +
                    c[year] +
                    '</b> individu' +
                    (+c[year] == 1 ? '' : 's') +
                    ' par ' +
                    (r * r) / 1000000 +
                    'km²'
                    : undefined

            const tooltipFunCh = (c) =>
                '2015: ' +
                c.ind2015 +
                '<br>2017: ' +
                c.ind2017 +
                '<br>2019: ' +
                c.ind2019

            //set default background filter
            for (let bgl of app.bgLayers) bgl.filterColor = (zf) => '#ffffff60'
            app.setBackgroundColor("white")

            if (layCode == 'color') {
                const colR = d3.interpolateOrRd

                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: year,
                            color: colR,
                            stretching: { fun: 'expRev', alpha: -7 },
                        }),
                        new gviz.StrokeStyle({
                            strokeColorCol: year,
                            strokeColor: (v) => (+v ? '#666' : ''),
                            maxZoom: 15,
                        }),
                    ],
                    {
                        pixNb: 1.8,
                        cellInfoHTML: tooltipFun,
                    }
                )

                //add legend
                app.layers[0].styles[0].legends.push(
                    new gviz.ColorLegend({
                        title: 'Number of inhabitants',
                        width: 400,
                        ticks: 5,
                        colorRamp: colR,
                        fun: (t, r, s) => s.max * gviz.sExpRevInverse(t, -7),
                    })
                )
            } else if (layCode == 'colorDark') {
                const colR = d3.interpolateMagma

                //set dark background filter color
                for (let bgl of app.bgLayers) bgl.filterColor = (zf) => '#000000c0'
                app.setBackgroundColor("black")

                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: year,
                            color: colR,
                            stretching: { fun: 'expRev', alpha: -7 },
                        }),
                        new gviz.StrokeStyle({
                            strokeColorCol: year,
                            strokeColor: (v) => (+v ? '#999' : ''),
                            maxZoom: 15,
                        }),
                    ],
                    {
                        pixNb: 1.8,
                        cellInfoHTML: tooltipFun,
                    }
                )

                //add legend
                app.layers[0].styles[0].legends.push(
                    new gviz.ColorLegend({
                        title: 'Number of inhabitants',
                        width: 400,
                        ticks: 5,
                        colorRamp: colR,
                        fun: (t, r, s) => s.max * gviz.sExpRevInverse(t, -7),
                    })
                )
            } else if (layCode == 'size') {
                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.ShapeColorSizeStyle({
                            color: () => col + 'bb',
                            sizeCol: year,
                            size: (v, r, s, zf) => 1.5 * r * gviz.sPow(v / s.max, 0.3),
                            shape: () => 'circle',
                        }),
                    ],
                    {
                        pixNb: 7,
                        cellInfoHTML: tooltipFun,
                    }
                )

                //add legend
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        title: 'Number of inhabitants',
                        exaggerationFactor: 0.8,
                        shape: 'circle',
                        fillColor: col,
                    }).style('padding', '0px 5px')
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        exaggerationFactor: 0.25,
                        shape: 'circle',
                        fillColor: col,
                    }).style('padding', '0px 5px')
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        exaggerationFactor: 0.02,
                        shape: 'circle',
                        fillColor: col,
                    }).style('padding', '0px 5px')
                )
            } else if (layCode == 'dots') {
                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.DotDensityStyle({
                            nbCol: year,
                            nb: (v, r, s, zf) => (((10 * r * r) / (zf * zf)) * v) / s.max,
                            dotSize: (r, zf) => 1.2 * zf,
                            color: () => col,
                        }),
                    ],
                    {
                        pixNb: 5,
                        cellInfoHTML: tooltipFun,
                    }
                )
            } else if (layCode == 'pillar') {
                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.PillarStyle({
                            heightCol: year,
                            //height: (v, r, s, z) => 15 * r * gviz.sPow(v / s.max, 0.7),
                            height: (v, r, s, z) => 10 * r * gviz.sExpRev(v / s.max, -5),
                            color: () => col + 'aa',
                            simple: true,
                            viewHeightFactor: 1,
                        }),
                    ],
                    {
                        pixNb: 6,
                        cellInfoHTML: tooltipFun,
                    }
                )
            } else if (layCode == 'joyplot') {
                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.JoyPlotStyle({
                            heightCol: year,
                            height: (v, r, s, zf) => 5 * r * Math.sqrt(v / s.max),
                            fillColor: () => col + 'bb',
                        }),
                    ],
                    {
                        pixNb: 5,
                        cellInfoHTML: tooltipFun,
                    }
                )
            } else if (layCode == 'smoothed') {
                //get year selection
                const sigma = document.querySelector('#sigmaTK').value

                const nb = 10
                const colR = d3.interpolateOrRd

                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz_sm.KernelSmoothingStyle({
                            value: (c) => +c[year],
                            filter: (c) => +c[year] > 0,
                            sigma: (r, zf) => (r * sigma) / 10,
                            filterSm: (v) => v > 0.02,
                            factor: 2,
                            styles: [
                                new gviz.SquareColorWGLStyle({
                                    colorCol: 'ksmval',
                                    color: colR,
                                    //opacity: (r,zf) => zf < 300? 0.75 : 1,
                                    tFun: (v, r, s) => {
                                        const v_ = gviz.sExp(v / s.max, -12)
                                        const cl = Math.floor(nb * v_) / nb
                                        return cl
                                    },
                                }),
                            ],
                            /*styles: gviz.TanakaStyle.get(
                            "ksmval",
                            {
                                tFun: (v, r, s, zf) => v == 0 ? 0 : gviz.sExpRev((v - s.min) / (s.max - s.min), -7), color: colR,
                                nb: nb,
                                //newShading: true,
                                filter: c => +c.ksmval > 0,
                            }),*/
                        }),
                    ],
                    {
                        pixNb: 6,
                        cellInfoHTML: tooltipFun,
                    }
                )

                //legend
                app.layers[0].styles[0].styles[0].legends.push(
                    new gviz.ColorLegend({
                        title: 'Number of inhabitants',
                        colorRamp: (t) => colR(Math.floor(t * nb) / nb),
                        //width: 500,
                        //ticks: 6,
                        //fun: (t, r, s) => s.min + (s.max - s.min) * gviz.sExpRevInverse(t, -7),
                        width: 200,
                        ticks: 2,
                        tickFormat: 'text',
                        fun: (t, r, s) => (t == 0 ? 'Low' : t == 1 ? 'High' : 'X'),
                    })
                )
            } else if (layCode == 'lego') {
                //const colR = d3.interpolateCubehelixDefault //interpolateOrRd
                //const nb = 12
                //const sigmaFun = (r, zf) => r * 0.5

                //const cols = []
                //for (let t = 0; t < 1; t += 1 / nb) cols.push(colR(t))

                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    gviz.LegoStyle.get(year, {
                        tFun: (v, r, s, zf) =>
                            v == 0 ? 0 : gviz.sExpRev((v - s.min) / (s.max - s.min), -7),
                        //colors: d3.schemeRdYlGn[10].reverse()
                    }),

                        /*[
            new gviz_sm.KernelSmoothingStyle({
                value: c => +c[year],
                filter: c => +c[year] > 0,
                factor: 10,
                threshold: 0.1,
                sigma: sigmaFun,
                styles:
                gviz.LegoStyle.get(year, {
                    filter: c => +c[year] > 0,
                    tFun: (v, r, s, zf) => v == 0 ? 0 : gviz.sExpRev((v - s.min) / (s.max - s.min), -7),
                    //colors: cols
                })
            })
        ]*/ {
                        pixNb: 7,
                        cellInfoHTML: tooltipFun,
                    }
                )

                //legend
                //const colsLego = ["#00852b", "#afd246", "#fac80a", "#bb805a", "#d67923", "#cb4e29", "#b40000", "#720012"]
                const colsLego = [
                    '#237841',
                    '#4B9F4A',
                    '#3CB371',
                    '#C7D23C',
                    '#F2CD37',
                    '#F8BB3D',
                    '#FFA70B',
                    '#D09168',
                    '#B67B50',
                    '#7C503A',
                    '#582A12',
                ],
                    nb = colsLego.length
                app.layers[0].styles[0] /*.styles[0]*/.legends
                    .push(
                        new gviz.ColorLegend({
                            title: 'Number of inhabitants',
                            colorRamp: (t) => colsLego[t == 1 ? nb - 1 : Math.floor(t * nb)],
                            width: 200,
                            ticks: 2,
                            tickFormat: 'text',
                            fun: (t, r, s) => (t == 0 ? 'Low' : t == 1 ? 'High' : 'X'),
                        })
                    )
            } else if (layCode == 'colorCh') {
                const streC = 0.22

                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.ShapeColorSizeStyle({
                            colorCol: 'd2015_2017',
                            color: (v, r, s) => {
                                const stre = gviz.sPow
                                let t = 0.5
                                if (s.min < 0 && v < 0) {
                                    t -= stre(v / s.min, streC) / 2
                                } else {
                                    t += stre(v / s.max, streC) / 2
                                }
                                t = 1 - t
                                return d3.interpolateSpectral(t)
                            },
                            shape: () => 'square',
                        }),
                        new gviz.StrokeStyle({ maxZoom: 15 }),
                    ],
                    {
                        pixNb: 2,
                        cellInfoHTML: tooltipFunCh,
                    }
                )

                //legend
                app.layers[0].styles[0].legends.push(
                    new gviz.ColorLegend({
                        title: 'Population change (number of inhabitants)',
                        ticks: 7,
                        width: 500,
                        colorRamp: d3.interpolateSpectral,
                        invert: true,
                        fun: (t, r, s) => {
                            const streI = gviz.sPowInverse
                            if (t < 0.5) return s.min * streI(1 - 2 * t, streC)
                            if (t > 0.5) return s.max * streI(2 * t - 1, streC)
                            return 0
                        },
                    })
                )
            } else if (layCode == 'colorChSmTK') {
                const colR = d3.interpolateSpectral
                const nb = 25
                const stre = gviz.sPow
                const streC = 0.3

                //get year selection
                const sigma = document.querySelector('#sigmaCCH').value

                //add layer
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz_sm.KernelSmoothingStyle({
                            value: (c) => +c.d2015_2017,
                            sigma: (r, zf) => (r * sigma) / 10,
                            factor: 2,
                            filterSm: (v) => Math.abs(v) > 0.0001,
                            //filter: c => !c.Ind_2015 && !c.Ind_2017,
                            styles: [
                                new gviz.SquareColorWGLStyle({
                                    colorCol: 'ksmval',
                                    color: (t) => colR(1 - t),
                                    //opacity: (r,zf) => zf < 300? 0.75 : 1,
                                    tFun: (v, r, s) => {
                                        let t = 0.5
                                        if (s.min < 0 && v < 0) {
                                            t += stre(v / s.min, streC) / 2
                                        } else {
                                            t -= stre(v / s.max, streC) / 2
                                        }
                                        t = 1 - t
                                        t = Math.floor(t * nb) / nb
                                        return t
                                    },
                                }),
                            ],
                            /*gviz.TanakaStyle.get("ksmval", {
                            tFun: (v, r, s, zf) => {
                                let t = 0.5
                                if (s.min < 0 && v < 0) {
                                    t += stre(v / s.min, streC) / 2
                                } else {
                                    t -= stre(v / s.max, streC) / 2
                                }
                                t = 1 - t;
                                t = Math.floor(t * nb) / nb
                                return t;
                            },
                            color: (t) => colR(1 - t),
                            nb: nb,
                            //newShading: true,
                        }),*/
                        }),
                    ],
                    {
                        pixNb: 6,
                        cellInfoHTML: tooltipFunCh,
                    }
                )

                //legend
                app.layers[0].styles[0].styles[0].legends.push(
                    new gviz.ColorLegend({
                        title: 'Population change',
                        width: 200,
                        ticks: 3,
                        colorRamp: (t) => colR(1 - Math.floor(t * nb) / nb),
                        tickFormat: 'text',
                        fun: (t, r, s) => (t == 0 ? 'Decrease' : t == 1 ? 'Increase' : 'Stable'),
                    })
                )
            } else if (layCode == 'sizeCh') {
                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.ShapeColorSizeStyle({
                            colorCol: 'd2015_2017',
                            color: (v) => (v > 0 ? '#d13c4bcc' : '#4288b5cc'),
                            sizeCol: 'd2015_2017',
                            size: (v, r, s, zf) => {
                                const max = Math.max(Math.abs(s.min), Math.abs(s.max))
                                return 1.5 * r * gviz.sPow(Math.abs(v) / max, 0.2)
                            },
                            shape: () => 'circle',
                        }),
                    ],
                    {
                        pixNb: 7,
                        cellInfoHTML: tooltipFunCh,
                    }
                )

                //legend
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        title: 'Population change',
                        exaggerationFactor: 0.9,
                        shape: 'circle',
                        labelUnitText: 'inhabitants',
                        fillColor: 'gray',
                    }).style('padding', '0px 5px')
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        exaggerationFactor: 0.2,
                        shape: 'circle',
                        labelUnitText: '',
                        fillColor: 'gray',
                    }).style('padding', '0px 5px')
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SizeLegend({
                        exaggerationFactor: 0.01,
                        shape: 'circle',
                        labelUnitText: '',
                        fillColor: 'gray',
                    }).style('padding', '0px 5px')
                )
                const lgCat = new gviz.ColorCategoryLegend({
                    shape: 'square',
                    colCat: [
                        ['#d13c4b', 'Increase'],
                        ['#4288b5', 'Decrease'],
                    ],
                })
                app.layers[0].styles[0].legends.push(lgCat)
            } else if (layCode == 'segmentCh') {
                const maxAngle = 60

                app.addLayerFromDataset(
                    popDataset[geo],
                    [
                        new gviz.SegmentStyle({
                            orientation: (c) => {
                                let a = (c.p2011_2018 * maxAngle) / 0.3
                                a = a < -maxAngle ? -maxAngle : a > maxAngle ? maxAngle : a
                                return a
                            },
                            colorCol: 'p2011_2018',
                            color: (v) =>
                                Math.abs(v) < 0.02 ? 'gray' : v > 0 ? '#d13c4bcc' : '#4288b5cc',
                            length: (v, r) => r,
                            //lengthCol: "Ind_2015",
                            //length: (v, r, s, zf) => r * gviz.sPow(v / s.max, 0.25),
                            widthCol: 'Ind_2017',
                            width: (v, r, s, zf) => 0.8 * r * gviz.sPow(v / s.max, 0.25),
                        }),
                    ],
                    {
                        pixNb: 10,
                        cellInfoHTML: tooltipFunCh,
                    }
                )

                //legend

                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentWidthLegend({
                        title: 'Population in 2018',
                        labelUnitText: 'inhab.',
                    })
                )

                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentOrientationLegend({
                        title: 'Population change',
                        labelUnitText: 'Strong increase',
                        color: '#d13c4b',
                        orientation: 60,
                    })
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentOrientationLegend({
                        labelUnitText: 'Weak increase',
                        color: '#d13c4b',
                        orientation: 30,
                    })
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentOrientationLegend({
                        labelUnitText: 'Stability (<1%)',
                        color: 'gray',
                        orientation: 0,
                    })
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentOrientationLegend({
                        labelUnitText: 'Weak decrease',
                        color: '#4288b5',
                        orientation: -30,
                    })
                )
                app.layers[0].styles[0].legends.push(
                    new gviz.SegmentOrientationLegend({
                        labelUnitText: 'Strong decrease',
                        color: '#4288b5',
                        orientation: -60,
                    })
                )
            }

            //redraw
            app.cg.redraw()
        }



        //
        const updateGeo = () => {
            //read GUI selection
            const geo = document.querySelector('#geo').value

            //clean layers
            app.bgLayers = []
            app.labelLayer = undefined
            app.boundaryLayer = undefined

            //set app parameters depending on the geographical selection

            //metropolitan france
            if (geo == "met") {
                app.setGeoCenter({ x: 3760000, y: 2750000 }) //{ x: 3763437, y: 2891045 })
                    .setZoomFactor(300)
                    .setBoundaryLayer(gviz_es.getEurostatBoundariesLayer())
                    .setLabelLayer(gviz_es.getEuronymeLabelLayer('FR', '20'))
                    .addBackgroundLayer({
                        url: "https://gisco-services.ec.europa.eu/maps/tiles/OSMPositronBackground/EPSG3035/",
                        resolutions: [156543.03392804097, 78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758, 1.19432856695, 0.597164283477939],
                        origin: [0, 6000000],
                        maxZoom: 50,
                    })
                    .addBackgroundLayer({
                        url: 'https://raw.githubusercontent.com/jgaffuri/mbxyz/main/pub/elevation_shading/',
                        resolutions: Array.from({ length: 9 }, (_, i) => 28.00132289714475 * Math.pow(2, 10 - i)),
                        origin: [0, 6000000],
                        filterColor: (zf) => '#ffffff60',
                        minZoom: 50,
                    })
            }

            //reunion
            else if (geo == "reun") {
                app.setGeoCenter({ x: 350000, y: 7660000 })
                    .setZoomFactor(75)
                    .setBoundaryLayer(gviz_es.getEurostatBoundariesLayer({ geo: "RE", crs: "32740", scale: "01M" }))
                //TODO labels
                //TODO background
            }

            //martinique
            else if (geo == "mart") {
                app.setGeoCenter({ x: 710000, y: 1620000 })
                    .setZoomFactor(75)
                    .setBoundaryLayer(gviz_es.getEurostatBoundariesLayer({ geo: "MQ", crs: "32620", scale: "01M" }))
                //TODO labels
                //TODO background
            }
            else { console.error("Unexpected geo: " + geo); return; }


            update();
        }


        //layer and year update
        document.querySelector('#layer').addEventListener('change', update)
        document.querySelector('#year').addEventListener('change', update)
        document.querySelector('#geo').addEventListener('change', updateGeo)

        //sigma selection
        document.getElementById('sigmaTK').oninput = update
        document.getElementById('sigmaCCH').oninput = update

        // show/hide labels
        document.querySelector('#label').addEventListener('change', function () {
            app.showLabels = this.checked
            app.cg.redraw()
        })

        // show/hide boundaries
        document.querySelector('#boundary').addEventListener('change', function () {
            app.showBoundaries = this.checked
            app.cg.redraw()
        })

        //initialise
        updateGeo()
    </script>

    <div style="
                position: absolute;
                right: 0px;
                bottom: 0px;
                width: auto;
                height: auto;
                padding: 1px;
                border: 0px;
                background: #ffffffcc;
            ">
        <span style="font-size: 0.8em; font-family: sans-serif"><a target="_blank" rel="nofollow noreferrer noopener"
                href="https://github.com/eurostat/gridviz" style="text-decoration: none">GridViz</a>
            | ©
            <a target="_blank" rel="nofollow noreferrer noopener" href="https://eurogeographics.org"
                style="text-decoration: none">EuroGeographics</a>
            | ©
            <a target="_blank" rel="nofollow noreferrer noopener" href="https://www.tuik.gov.tr"
                style="text-decoration: none">Turkstat</a>
        </span>
    </div>
</body>

</html>