<!DOCTYPE html>
<html lang="en" style="height:100%;">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title></title>
</head>

<body style="margin: 0; height:100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden;">
    <div id="viz-container" style="height:100%; width:100%;"></div>

    <div
        style="position: absolute; left: 20px; top: 20px; width: auto; height: auto; padding: 10px; border: 0px; border-radius: 5px; background: #FFFFFFCC; line-height: 1.6; box-shadow: 5px 5px 5px grey">
        <span style="font-size: 1em;">
            <span style="font-size: 1.5em; font-weight: bold;">Europe grid</span><br>
            <hr>
            <div id="layer">
                <span style="font-weight: bold;">Population</span>
                <br>
                <input type="radio" name="layer" id="y2018" value="y2018" checked>
                <label for="y2018">2018</label>
                <input type="radio" name="layer" id="y2011" value="y2011">
                <label for="y2011">2011</label>
                <input type="radio" name="layer" id="y2006" value="y2006">
                <label for="y2006">2006</label>
                <br>
                <input type="radio" name="layer" id="popChange" value="popChange">
                <label for="popChange">Change from </label>
                <select id="pcyIni" disabled>
                    <option value="2006" selected>2006</option>
                    <option value="2011">2011</option>
                    <option value="2018">2018</option>
                </select> to
                <select id="pcyFin" disabled>
                    <option value="2006">2006</option>
                    <option value="2011">2011</option>
                    <option value="2018" selected>2018</option>
                </select>
                <br>
                <input type="radio" name="layer" id="degurba" value="degurba">
                <label for="degurba">Degree of urbanisation</label>
                <br>
                <span style="font-weight: bold;">Accessibility</span>
                <br>
                <input type="radio" name="layer" id="rtp" value="rtp">
                <label for="rtp">Road transport performance</label>
                <br>
                <input type="radio" name="layer" id="accHealth" value="accHealth">
                <label for="accHealth">Healthcare services</label>
                <br>
                <input type="radio" name="layer" id="accEducPrim" value="accEducPrim">
                <label for="accEducPrim">Primary schools</label>
                <br>
                <span style="font-weight: bold;">Nature & topography</span>
                <br>
                <input type="radio" name="layer" id="lc" value="lc">
                <label for="lc">Land cover</label>
                <br>
                <input type="radio" name="layer" id="forest" value="forest">
                <label for="forest">Forest</label>
                <br>
                <input type="radio" name="layer" id="elevation" value="elevation">
                <label for="elevation">Elevation</label>
                <br>
            </div>

            <hr>
            <input type="checkbox" id="label" checked>
            <label for="label">City names</label>
            <input type="checkbox" id="boundary" checked>
            <label for="boundary">Boundaries</label>
            <hr>Source: <a href="https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/grids" target="_blank"
                rel="noopener noreferrer">European Commission</a>
        </span>
    </div>

    <script src="../build/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script>

        let containerDiv = document.getElementById("viz-container");
        const app = new gviz.App(containerDiv)
            .setGeoCenter({ x: 4313947, y: 2970049 }).setZoomFactor(600).setZoomFactorExtent([40, 7500])
            .setLabelLayer(gviz.getEuronymeLabelLayer()).setBoundaryLayer(gviz.getEurostatBoundariesLayer())
            .setViewFromURL()
            .addBackgroundLayer({
                url: "https://gisco-services.ec.europa.eu/maps/tiles/GreyEarth/EPSG3035/",
                resolutions: [156543.03392804097, 78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564],
                origin: [0, 6000000],
                filterColor: zf => "#ffffffd3",
            })

        //prepare datasets
        const ds = {}

        //population dataset
        ds.pop = app.makeMultiScaleTiledCSVGridDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/grid_pop_tiled/" + Math.round(r / 1000) + "km/",
            {
                preprocess: c => {
                    //prepare 2011 -> 2018 change data
                    if (!c["2011"] && !c["2018"]) c.d2011_2018 = 0
                    else if (!c["2011"] && c["2018"]) c.d2011_2018 = + c["2018"]
                    else if (c["2011"] && !c["2018"]) c.d2011_2018 = - c["2011"]
                    else c.d2011_2018 = c["2018"] - c["2011"]

                    //prepare 2006 -> 2011 change data
                    if (!c["2006"] && !c["2011"]) c.d2006_2011 = 0
                    else if (!c["2006"] && c["2011"]) c.d2006_2011 = +c["2011"]
                    else if (c["2006"] && !c["2011"]) c.d2006_2011 = - c["2006"]
                    else c.d2006_2011 = c["2011"] - c["2006"]

                    //prepare 2006 -> 2018 change data
                    if (!c["2006"] && !c["2018"]) c.d2006_2018 = 0
                    else if (!c["2006"] && c["2018"]) c.d2006_2018 = +c["2018"]
                    else if (c["2006"] && !c["2018"]) c.d2006_2018 = - c["2006"]
                    else c.d2006_2018 = c["2018"] - c["2006"]
                }
            }
        )

        //accessibility dataset
        ds.acc = app.makeMultiScaleTiledCSVGridDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/accessibility/tiled/" + r + "m/",
        )

        //road transp perf dataset
        ds.rtp = app.makeMultiScaleTiledCSVGridDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/road_transp_perf/tiled/" + r + "m/",
        )

        //degurba dataset
        ds.degurba = app.makeMultiScaleTiledCSVGridDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/degurba/tiled/" + r + "m/",
            {
                preprocess: c => {
                    if (+c.TOT != 1) c.c = "zzz";
                    else
                        c.c = +c.uc ? "uc" : +c.du ? "du" : +c.sdu ? "sdu" : +c.sbu ? "sbu" : +c.r ? "r" : +c.lr ? "lr" : +c.vlr ? "vlr" : "NA";
                },
            }
        )

        //land cover dataset
        ds.lc = app.makeMultiScaleTiledCSVGridDataset(
            [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/clc/tiled/" + r + "m/",
        )

        //forest dataset
        ds.forest = app.makeMultiScaleTiledCSVGridDataset(
            [/*100, 200, 500,*/ 1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/forest/tiled/" + r + "m/",
        )

        //elevation dataset
        ds.ele = app.makeMultiScaleTiledCSVGridDataset(
            [500, 1000, 2000, 5000, 10000, 20000, 50000, 100000],
            r => "https://raw.githubusercontent.com/eurostat/gridviz/master/assets/csv/Europe/elevation/tiled/" + r + "m/",
        )

        //
        const update = () => {

            //read GUI selection
            const layCode = document.querySelector('input[name="layer"]:checked').value

            //remove layers
            app.layers = []

            //select layer and style
            if (layCode === "y2006" || layCode === "y2011" || layCode === "y2018") {
                const layCode_ = layCode.replace("y", "")
                app.addLayerFromDataset(
                    ds.pop,
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: layCode_,
                            color: d3.interpolateOrRd,
                            stretching: { fun: "expRev", alpha: -7 }
                        }),
                        new gviz.StrokeStyle({ strokeColorCol: layCode_, strokeColor: v => +v ? "#666" : "", maxZoom: 80 })
                    ],
                    {
                        pixNb: 2,
                        cellInfoHTML: c => +c[layCode_] ? "<b>" + c[layCode_] + "</b> inhabitant(s) in " + layCode_ : undefined
                    }
                )
                //legend
                app.layers[0].styles[0].legends.push(new gviz.ColorLegend({ title: "Number of inhabitants", ticks: 5, colorRamp: d3.interpolateOrRd, fun: (t, r, s) => s.max * gviz.sExpRevInverse(t, 7) }))

            } else if (layCode === "popChange") {

                //
                const yIni = document.querySelector('#pcyIni').value
                const yFin = document.querySelector('#pcyFin').value
                if (yIni != yFin) {
                    const layCode_ = "d" + yIni + "_" + yFin

                    app.addLayerFromDataset(
                        ds.pop,
                        [
                            new gviz.ShapeColorSizeStyle({
                                colorCol: layCode_,
                                color: (v, r, s) => {
                                    const max = Math.max(Math.abs(s.min), Math.abs(s.max))
                                    const t = Math.sign(v) * gviz.sPow(Math.abs(v) / max, 0.2) / 2 + 0.5
                                    return d3.interpolateSpectral(1 - t);
                                },
                                shape: () => "square",
                            }),
                            new gviz.StrokeStyle({ maxZoom: 80 })
                        ],
                        {
                            pixNb: 2,
                            cellInfoHTML: c => (
                                "2011: " + c["2011"] + "<br>2018: " + c["2018"]
                            )
                                + "<br>"
                                + "<b>" + (c[layCode_] == 0 ? "No change" : (c[layCode_] > 0 ? "+" : "") + c[layCode_] + " inhabitants") + "</b>"
                        }
                    )
                    //legend
                    app.layers[0].styles[0].legends.push(
                        new gviz.ColorLegend({
                            title: "Population change", ticks: 5, colorRamp: d3.interpolateSpectral, invert: true,
                            fun: (t, r, s) => {
                                const max = Math.max(Math.abs(s.min), Math.abs(s.max))
                                return (t < 0.5 ? -1 : 1) * max * gviz.sPow(Math.abs(2 * t - 1), 1 / 0.2)
                            }
                        })
                    )

                }


                //urbanisation

            } else if (layCode === "degurba") {

                app.addLayerFromDataset(
                    ds.pop,
                    [
                        new gviz.ShapeColorSizeStyle({
                            color: () => "#666",
                            sizeCol: "2018",
                            size: (v, r, s, zf) => 0.8 * r * gviz.sPow(v / s.max, 0.3),
                            shape: () => "circle",
                        })
                    ],
                    {
                        pixNb: 8,
                        maxZoom: 120,
                    }
                )

                const degurbaColors = {
                    "uc": "#d53e4f",
                    "du": "#f46d43",
                    "sdu": "#fdae61",
                    "sbu": "#fee08b",
                    "r": "#e6f598",
                    "lr": "#abdda4",
                    "vlr": "#66c2a5",
                    "NA": "gray",
                }

                app.addLayerFromDataset(
                    ds.degurba,
                    [
                        new gviz.CompositionStyle({
                            color: degurbaColors,
                            type: () => "flag",
                            //stripesOrientation: () => 0,
                            sizeCol: "TOT",
                            size: (v, r, s, z) => 1 * r * gviz.sPow(v / s.max, 0.5),
                            minZoom: 120,
                        }),
                        /*new gviz.SquareColorCatWGLStyle({
                            colorCol: "c",
                            color: degurbaColors,
                            maxZoom: 400,
                            minZoom: 120,
                        }),*/
                        new gviz.SideCatStyle({
                            col: "c",
                            color: degurbaColors,
                            width: (side, r, z) => z * 3,
                            fillColor: (c) => degurbaColors[c.c] + "55",
                            maxZoom: 120,
                        }),
                    ],
                    {
                        pixNb: 4,
                        cellInfoHTML: c => {
                            if (!c.TOT) return "No information";
                            if (c.TOT == 1) return +c.uc ? "Urban centre" : +c.du ? "Dense urban cluster" : +c.sdu ? "Semi-dense urban cluster" : +c.sbu ? "Suburban" : +c.r ? "Rural" : +c.lr ? "Low density rural" : +c.vlr ? "Very low density rural" : "Unknown";
                            const out = []
                            if (+c.uc) out.push(c.uc + " Dense urban cluster<br>")
                            if (+c.sdu) out.push(c.sdu + " Semi-dense urban cluster<br>")
                            if (+c.sbu) out.push(c.sbu + " Suburban<br>")
                            if (+c.r) out.push(c.r + " Rural<br>")
                            if (+c.lr) out.push(c.lr + " Low density rural<br>")
                            if (+c.vlr) out.push(c.vlr + " Very low density rural<br>")
                            if (+c.NA) out.push(c.NA + " Unknown<br>")
                            return out.join("")
                        }
                    }
                )
                //legend
                app.layers[0].styles[0].legends.push(new gviz.SizeLegend({ shape: "circle", labelUnitText: "inhab.", fillColor: "#666d" }))
                //TODO add legend with classified colors


                //road transport performence
            } else if (layCode === "rtp") {

                app.addLayerFromDataset(
                    ds.rtp,
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: "rp", // pp ra rp
                            color: d3.interpolateGnBu,
                            tFun: (v, r, s) => Math.min(v, 100) / 100,
                            stretching: { fun: "expRev", alpha: 2 },
                        }),
                        new gviz.StrokeStyle({ strokeColorCol: "rp", strokeColor: v => +v ? "#666" : "", maxZoom: 100 })
                    ],
                    {
                        pixNb: 1,
                        cellInfoHTML: c => "<b>" + c.rp + "</b> road transport performance",
                        preprocess: (c) => c.rp != ""
                    }
                )

                //legend
                app.layers[0].styles[0].legends.push(new gviz.ColorLegend({
                    title: "Road transport performance",
                    width: 300,
                    ticks: 9,
                    colorRamp: d3.interpolateGnBu,
                    fun: (t, r, s) => 100 * gviz.sExpRevInverse(t, 2),
                }))


                //accessibility
            } else if (layCode === "accHealth") {
                const breaks = [0, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 90]
                app.addLayerFromDataset(
                    ds.acc,
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: "avg_time_nearest_h",
                            color: d3.interpolateSpectral,
                            tFun: (v, r, s) => {
                                if (v === "NA") return
                                let i = 0
                                for (let b of breaks) {
                                    if (+v <= b) break;
                                    i++
                                }
                                return gviz.sPow(1 - (i - 1) / breaks.length, 2)
                            },
                        }),
                        new gviz.StrokeStyle({ maxZoom: 80 }),
                        new gviz.ShapeColorSizeStyle({
                            color: () => "#000000dd",
                            sizeCol: "TOT_P",
                            size: (v, r, s, zf) => 1.2 * r * gviz.sPow(v / s.max, 0.3),
                            shape: () => "circle",
                        })
                    ],
                    {
                        pixNb: 8,
                        cellInfoHTML: c => "<b>" + c.avg_time_nearest_h + "</b> min. to nearest service<br><b>" + c.TOT_P + "</b> inhabitant(s)"
                    }
                )
                //legend
                //TODO add legend with classified colors
                //lay.styles[0].legends.push(new gviz.ColorLegend({}))
                app.layers[0].styles[2].legends.push(new gviz.SizeLegend({ shape: "circle", labelUnitText: "inhab.", fillColor: "#000000dd" }))

            } else if (layCode === "accEducPrim") {
                const breaks = [0, 2, 4, 6, 8, 10, 20, 30]
                app.addLayerFromDataset(
                    ds.acc,
                    [
                        new gviz.SquareColorWGLStyle({
                            colorCol: "avg_time_nearest_ep",
                            color: d3.interpolateSpectral,
                            tFun: (v, r, s) => {
                                if (v === "NA") return
                                let i = 0
                                for (let b of breaks) {
                                    if (+v <= b) break;
                                    i++
                                }
                                return gviz.sPow(1 - (i - 1) / breaks.length, 2)
                            },
                        }),
                        new gviz.StrokeStyle({ maxZoom: 80 }),
                        new gviz.ShapeColorSizeStyle({
                            color: () => "#000000dd",
                            sizeCol: "TOT_P",
                            size: (v, r, s, zf) => 1.2 * r * gviz.sPow(v / s.max, 0.3),
                            shape: () => "circle",
                        })
                    ],
                    {
                        pixNb: 8,
                        cellInfoHTML: c => "<b>" + c.avg_time_nearest_ep + "</b> min. to nearest school<br><b>" + c.TOT_P + "</b> inhabitant(s)"
                    }
                )
                //legend
                //TODO add legend with classified colors
                //lay.styles[0].legends.push(new gviz.ColorLegend({}))
                app.layers[0].styles[2].legends.push(new gviz.SizeLegend({ shape: "circle", labelUnitText: "inhab.", fillColor: "#000000dd" }))

            } else if (layCode === "lc") {

                const clcColors = {
                    "1": "#e6004d",
                    "2": "#ff0000",
                    "3": "#cc4df2",
                    "4": "#cc0000",
                    "5": "#e6cccc",
                    "6": "#e6cce6",
                    "7": "#a600cc",
                    "8": "#a64d00",
                    "9": "#ff4dff",
                    "10": "#ffa6ff",
                    "11": "#ffe6ff",
                    "12": "#ffffa8",
                    "13": "#ffff00",
                    "14": "#e6e600",
                    "15": "#e68000",
                    "16": "#f2a64d",
                    "17": "#e6a600",
                    "18": "#e6e64d",
                    "19": "#ffe6a6",
                    "20": "#ffe64d",
                    "21": "#e6cc4d",
                    "22": "#f2cca6",
                    "23": "#80ff00",
                    "24": "#00a600",
                    "25": "#4dff00",
                    "26": "#ccf24d",
                    "27": "#a6ff80",
                    "28": "#a6e64d",
                    "29": "#a6f200",
                    "30": "#e6e6e6",
                    "31": "#cccccc",
                    "32": "#ccffcc",
                    "33": "#000000",
                    "34": "#a6e6cc",
                    "35": "#a6a6ff",
                    "36": "#4d4dff",
                    "37": "#ccccff",
                    "38": "#e6e6ff",
                    "39": "#a6a6e6",
                    "40": "#00ccf2",
                    "41": "#80f2e6",
                    "42": "#00ffa6",
                    "43": "#a6ffe6",
                    "44": "#e6f2ff",
                    "48": "gray"
                }

                const clcLabels = {
                    "1": "Continuous urban fabric",
                    "2": "Discontinuous urban fabric",
                    "3": "Industrial or commercial units",
                    "4": "Road and rail networks and associated land",
                    "5": "Port areas",
                    "6": "Airports",
                    "7": "Mineral extraction sites",
                    "8": "Dump sites",
                    "9": "Construction sites",
                    "10": "Green urban areas",
                    "11": "Sport and leisure facilities",
                    "12": "Non-irrigated arable land",
                    "13": "Permanently irrigated land",
                    "14": "Rice fields",
                    "15": "Vineyards",
                    "16": "Fruit trees and berry plantations",
                    "17": "Olive groves",
                    "18": "Pastures",
                    "19": "Annual crops associated with permanent crops",
                    "20": "Complex cultivation patterns",
                    "21": "Land principally occupied by agriculture with significant areas of natural vegetation",
                    "22": "Agro-forestry areas",
                    "23": "Broad-leaved forest",
                    "24": "Coniferous forest",
                    "25": "Mixed forest",
                    "26": "Natural grasslands",
                    "27": "Moors and heathland",
                    "28": "Sclerophyllous vegetation",
                    "29": "Transitional woodland-shrub",
                    "30": "sands",
                    "31": "Bare rocks",
                    "32": "Sparsely vegetated areas",
                    "33": "Burnt areas",
                    "34": "Glaciers and perpetual snow",
                    "35": "Inland marshes",
                    "36": "Peat bogs",
                    "37": "Salt marshes",
                    "38": "Salines",
                    "39": "Intertidal flats",
                    "40": "Water courses",
                    "41": "Water bodies",
                    "42": "Coastal lagoons",
                    "43": "Estuaries",
                    "44": "Sea and ocean",
                    "48": "No data"
                }

                app.addLayerFromDataset(
                    ds.lc,
                    [
                        new gviz.SquareColorCatWGLStyle({
                            colorCol: "clc",
                            color: clcColors,
                            minZoom: 100
                        }),
                        new gviz.SideCatStyle({
                            col: "clc",
                            color: clcColors,
                            width: (side, r, z) => z * 3,
                            fillColor: (c) => clcColors[c.clc] + "99",
                            maxZoom: 100
                        }),
                    ],
                    {
                        pixNb: 1.75,
                        cellInfoHTML: c => clcLabels[c.clc],
                    }
                )


                //forest
            } else if (layCode === "forest") {

                app.addLayerFromDataset(
                    ds.forest,
                    [
                        new gviz.ShapeColorSizeStyle({
                            sizeCol: "tcd",
                            size: (v, r, s, zf) => 1.2 * r * Math.sqrt(v / 100),
                            colorCol: "dlt",
                            color: (v) => {
                                //none
                                if (v == 0) return "#c6df58";
                                //coniferous
                                if (v == 2) return "#38a43b";
                                //broad
                                return "#9fd045";
                            },
                            shape: () => "circle",
                        }),
                        new gviz.StrokeStyle({
                            sizeCol: "tcd",
                            size: (v, r, s, zf) => 1.2 * r * Math.sqrt(v / 100),
                            strokeColor: () => "#006600",
                            strokeWidth: (v, r, s, z) => 0.3 * z,
                            shape: () => "circle"
                        })
                    ],
                    {
                        pixNb: 6,
                        cellInfoHTML: c => {
                            let st = "Tree cover density: <b>" + c.tcd + "%</b>"
                            if (c.dlt == "1") st += "<br>Mainly broadleaved trees"
                            if (c.dlt == "2") st += "<br>Mainly coniferous trees"
                            return st;
                        },
                    }
                )

                //legend
                app.layers[0].styles[0].legends = [
                    new gviz.ColorCategoryLegend({
                        title: "Dominant leaf tree", colCat: [
                            ["#c6df58", "None"],
                            ["#9fd045", "Mainly broadleaved"],
                            ["#38a43b", "Mainly coniferous"],
                        ],
                        shape: "square",
                    }),
                    new gviz.SizeLegend({ shape: "circle", labelUnitText: "% tree cover density", fillColor: "#666d" })
                ]


            } else if (layCode === "elevation") {

                app.addLayerFromDataset(
                    ds.ele,
                    gviz.TanakaStyle.get("elevation", {
                        nb: 10,
                        //color: d3.interpolateCubehelixDefault,
                        color: d3.interpolateRgbBasis(["#a8bc9f", "#bbcc9e", "#ebe8c1", "#dca255", "#d38487", "#fbf4f2"]),
                        widthFactor: 0.15,
                        tFun: (v, r, s, zf) => gviz.sPow((Math.max(v, 0) - s.min) / (s.max - s.min), 0.5),
                    }),
                    {
                        pixNb: 3,
                        cellInfoHTML: c => "<b>" + c.elevation + "</b> m"
                    }
                )

            } else {
                console.log("Unexpected layer code: " + layCode);
                return;
            }

            //redraw
            app.cg.redraw();
        }

        //layer selection change
        document.querySelector('#layer').addEventListener('change', function () {
            const layCode = document.querySelector('input[name="layer"]:checked').value
            if (layCode == "popChange") {
                //enable years lists
                document.querySelector('#pcyIni').disabled = false
                document.querySelector('#pcyFin').disabled = false
            } else {
                //disable years lists
                document.querySelector('#pcyIni').disabled = true
                document.querySelector('#pcyFin').disabled = true
            }

            update();
        })

        //population change - years change
        document.querySelector('#pcyIni').addEventListener('change', update)
        document.querySelector('#pcyFin').addEventListener('change', update)

        // show/hide labels
        document.querySelector('#label').addEventListener('change', function () {
            app.showLabels = this.checked
            app.cg.redraw();
        });

        // show/hide boundaries
        document.querySelector('#boundary').addEventListener('change', function () {
            app.showBoundaries = this.checked
            app.cg.redraw();
        });


        //select layer from URL
        const ls = gviz.getParameterByName("lay")
        if (ls) {
            const b = document.querySelector('#' + ls)
            if (b) b.checked = true
        }


        //initialise
        update()

    </script>

    <div
        style="position: absolute; right: 0px; bottom: 0px; width: auto; height: auto; padding: 1px; border: 0px; background: #FFFFFFCC;">
        <span style="font-size: 0.8em;"><a href="https://github.com/eurostat/gridviz"
                style="text-decoration:none">GridViz</a> |
            © <a href="https://eurogeographics.org" style="text-decoration:none">EuroGeographics</a></span>
    </div>

</body>

</html>