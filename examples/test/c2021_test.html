<!DOCTYPE html>
<html lang="en" style="height: 100%">

<head>
    <meta name="viewport" content="maximum-scale=1.0, user-scalable=no" />
    <title>Gridviz - Custom style</title>
</head>

<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">
    <div id="viz-container" style="height: 100%; width: 100%"></div>

    <script src="../../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>

    <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-format@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script>
    <script>
        let containerDiv = document.getElementById('viz-container')

        //generic function for quantile color maps
        const quantileColorScale = (dataFun, nbCl = 12, colR = d3.interpolateYlOrRd, prop = "quantileColorScale") => {
            const scale = d3.scaleQuantile().range(Array.from({ length: nbCl }, (_, i) => colR(i / (nbCl - 1))))
            return (cells) => {
                scale.domain(cells.map(dataFun));
                const out = {}; out[prop] = scale
                return out;
            }
        }

        //generic function for size map
        const sizeScale = (dataFun, exponent = 0.5, minValue = 0, minSizePix = 0, maxSizeFactor = 1.41, prop = "sizeScale") => {
            const scale = d3.scalePow().exponent(exponent)
            return (cells, r, zf) => {
                scale.domain([minValue, d3.max(cells, dataFun)])
                scale.range([minSizePix * zf, r * maxSizeFactor])
                const out = {}; out[prop] = scale
                return out;
            }
        }

        //generic function for size map - quantile
        const sizeQuantileScale = (dataFun, nbCl = 12, minSizePix = 1, maxSizeFactor = 1, prop = "sizeQuantileScale") => {
            const scale = d3.scaleQuantile()
            return (cells, r, zf) => {
                scale.domain(cells.map(dataFun))
                const minS = minSizePix * zf, maxS = r * maxSizeFactor
                scale.range(Array.from({ length: nbCl }, (_, i) => minS + i * (maxS - minS) / (nbCl - 1)))
                const out = {}; out[prop] = scale
                return out;
            }
        }



        //style

        //total population - color
        const styleTotalColor = new gviz.ShapeColorSizeStyle_({
            color: (c, r, zf, vc) => vc.quantileColorScale(c.T),
            viewContext: quantileColorScale((c) => +c.T, 12, d3.interpolateYlOrRd)
        })

        //total population - size
        const styleTotalSize = new gviz.ShapeColorSizeStyle_({
            size: (c, r, zf, vc) => vc.sizeScale(+c.T),
            shape: () => "circle",
            viewContext: sizeScale((c) => +c.T, 0.35)
        })

        //total population - size quantile
        const styleTotalSizeQ = new gviz.ShapeColorSizeStyle_({
            size: (c, r, zf, vc) => vc.sizeQuantileScale(+c.T),
            shape: () => "circle",
            viewContext: sizeQuantileScale((c) => +c.T, 12)
        })

        //by sex
        const styleSex = new gviz.ShapeColorSizeStyle_({
            color: (c, r, zf, vc) => {
                return "red"
                //const max = Math.max(Math.abs(vc.colorMinMax[0]), Math.abs(vc.colorMinMax[1]))
                //const t = (Math.sign(c.indMF) * gviz.sPow(Math.abs(c.indMF) / max, 0.03)) / 2 + 0.5
                //return d3.interpolateSpectral(1 - t)
            },
            size: (c, r, zf, vc) => vc.sizeScale(+c.T),
            shape: () => 'circle',
            viewContext: sizeScale((c) => +c.T, 0.2)
        })

        //by age
        const colAge = d3.interpolateSpectral
        const styleAge = new gviz.CompositionStyle({
            color: {
                Y_LT15: colAge(0.2),
                "Y15-64": colAge(0.4),
                Y_GE65: colAge(0.9),
            },
            type: () => 'agepyramid',
            sizeCol: 'T',
            size: (v, r, s, zf) => r * gviz.sPow(v / s.max, 0.1, 0),
            agePyramidHeight: (c, r) => 0.95 * r,
        })

        //place of birth
        const styleBirthPlace = new gviz.CompositionStyle({
            color: {
                NAT: "#fed9a6", //light mostard
                EU_OTH: "#7570b3", //blueish
                OTH: "#d95f02", //orange
            },
            type: () => 'halftone', //flag, piechart, ring, segment, radar, agepyramid, halftone
            sizeCol: 'T',
            size: (v, r, s, zf) => 1.3 * r * gviz.sPow(v / s.max, 0.25, 0),
            //agePyramidHeight: (c, r) => 0.95 * r,
        })


        const style = styleSex
        const pixNb = 3

        /*
        "T" >= Total population

        "F" >= Women
        "M" >= Men

        "Y_LT15" >= Age under 15 years
        "Y15-64" >= Age 15 to 64 years
        "Y_GE65" >= Age 65 years and older

        "EMP" >= Employed (working population)

        "NAT" >= Born in the country
        "EU_OTH" >= Born in another EU member state
        "OTH" >= Born outside the EU

        "SAME" >= Residence unchanged (as of January 1, 2021, compared to January 1, 2020)
        "CHG_IN" >= Moved within the Netherlands (as of January 1, 2021, compared to January 1, 2020)
        "CHG_OUT" >= Moved from outside the Netherlands (as of January 1, 2021, compared to January 1, 2020)
        */



        //make application with custom style
        new gviz.App(containerDiv)
            .setGeoCenter({ x: 4598000, y: 2715000 })
            .setZoomFactor(700)
            .addMultiScaleTiledGridLayer(
                [1000, 2000, 5000, 10000, 20000, 50000, 100000],
                (r) =>
                    'http://localhost:1234/' +
                    r +
                    'm/',
                [style],
                {
                    pixNb: pixNb,
                    preprocess: (c) => {
                        if (!c.T || +c.T == 0) return false

                        //if (+c.F + +c.M != c.T) console.error("Error found in sex total")
                        c.indMF = +c.M - (+c.F)
                        c.indMF = (100 * c.indMF) / +c.T
                        if (isNaN(c.indMF)) c.indMF = 0
                    }
                }

            )

    </script>
</body>

</html>