<body style="margin: 0; height: 100%; font-family: Arial, Helvetica, sans-serif; overflow: hidden">
    <div id="map" style="height: 600px; width: 100%"></div>

    <div style="
        position: absolute;
        left: 20px;
        top: 20px;
        width: auto;
        height: auto;
        padding: 10px;
        border: 0px;
        border-radius: 5px;
        background: #ffffffcc;
        line-height: 1.6;
        box-shadow: 5px 5px 5px grey;
    ">
        <div id="layer">
            <span style="font-size: 1em">
                <input type="radio" name="layer" id="pop" value="pop" checked />
                <label for="pop">Total population</label>
                <br />
                <input type="radio" name="layer" id="sex" value="sex" />
                <label for="sex">Sex</label>
                <br />
                <input type="radio" name="layer" id="emp" value="emp" />
                <label for="emp">Employment</label>
                <br />
                <input type="radio" name="layer" id="age" value="age" />
                <label for="age">Age</label>
                <br />
                <input type="radio" name="layer" id="mobility" value="mobility" />
                <label for="mobility">Mobility</label>
                <br />
                <input type="radio" name="layer" id="pob" value="pob" />
                <label for="pob">Birth place</label>
                <br />
                <hr />
                <input type="radio" name="layer" id="share" value="share" />
                <label for="share">Share of</label>
                <select id="share_">
                    <option value="F">Women</option>
                    <option value="M">Men</option>
                    <option value="Y_LT15">Age under 15 years</option>
                    <option value="Y15-64">Age 15 to 64 years</option>
                    <option value="Y_GE65">Age 65 years and older</option>
                    <option value="EMP" selected>Employed</option>
                    <option value="SAME">Residence unchanged (2020/2021)</option>
                    <option value="CHG_IN">Moved within the country (2020/2021)</option>
                    <option value="CHG_OUT">Moved from outside the country (2020/2021)</option>
                    <option value="NAT">Born in the country</option>
                    <option value="EU_OTH">Born in another EU member state</option>
                    <option value="OTH">Born outside the EU</option>
                </select>
                <br />
                <input type="checkbox" id="sbtp" checked />
                <label for="sbtp">Size by total population</label><br />
        </div>
        <hr />
        <input type="checkbox" id="label" checked />
        <label for="label">City names</label><br />
        <input type="checkbox" id="boundary" checked />
        <label for="boundary">Boundaries</label><br />
        <input type="checkbox" id="background" checked />
        <label for="background">Background</label>
        </span>
    </div>

    <script src="../../dist/gridviz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gridviz-eurostat@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale-chromatic@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-format@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script>
    <script>

        /*
        "T" >= Total population

        "F" >= Women
        "M" >= Men

        "Y_LT15" >= Age under 15 years
        "Y15-64" >= Age 15 to 64 years
        "Y_GE65" >= Age 65 years and older

        "EMP" >= Employed (working population)

        "SAME" >= Residence unchanged (as of January 1, 2021, compared to January 1, 2020)
        "CHG_IN" >= Moved within the country (as of January 1, 2021, compared to January 1, 2020)
        "CHG_OUT" >= Moved from outside the country (as of January 1, 2021, compared to January 1, 2020)

        "NAT" >= Born in the country
        "EU_OTH" >= Born in another EU member state
        "OTH" >= Born outside the EU
        */

        //define map with initial view
        const map = new gridviz.Map(document.getElementById('map'), { x: 4598000, y: 2715000, z: 700, zoomExtent: [10, 10000] })
            .addZoomButtons()
            .setViewFromURL()

        const backgroundLayer1 = new gridviz.BackgroundLayer({
            url: 'https://raw.githubusercontent.com/jgaffuri/mbxyz/main/pub/elevation_shading/',
            resolutions: Array.from({ length: 9 }, (_, i) => 28.00132289714475 * Math.pow(2, 10 - i)),
            origin: [0, 6000000],
            filterColor: () => '#ffffffc0',
            visible: (z) => z > 50,
        })

        const backgroundLayer2 = new gridviz.BackgroundLayer(
            gridviz_eurostat.giscoBackgroundLayer("OSMPositronBackground", 18, "EPSG3035", {
                visible: (z) => z <= 50,
            })
        )

        //define boundaries layer
        const boundariesLayer = new gridviz.GeoJSONLayer(gridviz_eurostat.getEurostatBoundariesLayer())

        //make label layer
        const labelLayer = new gridviz.LabelLayer(gridviz_eurostat.getEuronymeLabelLayer())

        //function to compute the percentage of a cell value
        const computePercentage = (c, col, totalFunction) => {
            const total = totalFunction(c)
            if (total == 0) { c["s" + col] = undefined; return }
            c["s" + col] = +c[col] / total * 100
            if (c["s" + col] < 0 || c["s" + col] > 100 || isNaN(total)) console.log("Unexpected rate for " + col + ": " + c["s" + col], c[col], total)
            c["s" + col] = c["s" + col] > 100 ? 100 : c["s" + col] < 0 ? 0 : c["s" + col]
        }

        //define multi resolution dataset
        const dataset = new gridviz.MultiResolutionDataset(
            [1000, 2000, 5000, 10000, 20000, 50000, 100000],
            resolution => new gridviz.TiledGrid(map, 'http://localhost:1234/' + resolution + 'm/'),
            {
                preprocess: (c) => {
                    if (!c.T || +c.T == 0) return false

                    //male/female index
                    //if (+c.F + +c.M != c.T) console.error("Error found in sex total")
                    c.indMF = +c.M - (+c.F)
                    c.indMF = (100 * c.indMF) / (+c.M + +c.F)
                    if (isNaN(c.indMF)) c.indMF = 0

                    //compute percentages
                    computePercentage(c, "F", c => +c.F + +c.M)
                    computePercentage(c, "M", c => +c.F + +c.M)
                    computePercentage(c, "Y_LT15", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "Y15-64", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "Y_GE65", c => +c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65)
                    computePercentage(c, "EMP", c => c.T)
                    computePercentage(c, "NAT", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "EU_OTH", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "OTH", c => +c.NAT + +c.EU_OTH + +c.OTH)
                    computePercentage(c, "SAME", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                    computePercentage(c, "CHG_IN", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                    computePercentage(c, "CHG_OUT", c => +c.SAME + +c.CHG_IN + +c.CHG_OUT)
                }
            }
        )

        //make grid layer
        const gridLayer = new gridviz.GridLayer(dataset, [])

        //add layers to map
        map.layers = [backgroundLayer1, backgroundLayer2, gridLayer, boundariesLayer, labelLayer]

        //
        const update = () => {
            //read GUI selection
            const layCode = document.querySelector('input[name="layer"]:checked').value

            //set style
            if (layCode === 'pop') {

                const nbClasses = 6
                const colors = d3.schemeYlOrRd[nbClasses]
                gridLayer.styles = [
                    new gridviz.ShapeColorSizeStyle({
                        color: (c, r, z, viewScale) => viewScale(c.T),
                        viewScale: gridviz.viewScaleColor({
                            valueFunction: (c) => +c.T,
                            //colorScale: d3.interpolateYlOrRd,
                            colors: colors,
                            stretching: gridviz.logarithmicScale(-7)
                        }),
                        blendOperation: (z) => z < 100 ? "multiply" : "source-over",
                    }),
                    new gridviz.StrokeStyle({ visible: (z) => z < 50 }),
                ]

                //legend
                gridLayer.styles[0].legends = [
                    new gridviz.ColorDiscreteLegend({
                        title: "Population",
                        width: 300,
                        colors: () => colors,
                        breaks: (viewScale) => viewScale?.breaks.map(b => Math.round(b)),
                    })
                ]

                gridLayer.minPixelsPerCell = 1.5

                gridLayer.cellInfoHTML = (c) => '<b>' + c.T + '</b> person' + (+c.T == 1 ? '' : 's')

            } else if (layCode === 'sex') {

                //sex - color classifier
                const breaks = [-20, -7, -2, -0.5, 0.5, 2, 7, 20]
                const sexColorClassifier = gridviz.colorClassifier(breaks, d3.schemeSpectral[breaks.length + 1])

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c, r, z, viewScale) => sexColorClassifier(c.indMF),
                    size: (c, r, z, viewScale) => viewScale(c.T),
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 4, maxSizeFactor: 1.1 }),
                    shape: () => 'circle',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })
                gridLayer.styles = [style]

                gridLayer.minPixelsPerCell = 5

                style.legends = []

                //sex color legend
                style.legends.push(new gridviz.ColorDiscreteLegend({
                    title: "Sex balance, in %",
                    width: 300,
                    colors: () => sexColorClassifier.colors,
                    breaks: () => sexColorClassifier.breaks,
                }))

                //population size legend
                style.addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + (+c.F + +c.M) + '</b> person' + (+c.F + +c.M == 1 ? '' : 's') + '<br>' +
                    c.M + ' m' + (c.M == 1 ? "a" : "e") + 'n<br>' +
                    c.F + ' wom' + (c.F == 1 ? 'a' : 'e') + 'n<br>' +
                    'Difference: <b>' + (c.indMF > 0 ? '+' : '') + d3.format('.1f')(c.indMF) + ' % men</b>'

            } else if (layCode === 'emp') {

                const breaks = [30, 40, 45, 50, 55, 60, 70]
                const empColorClassifier = gridviz.colorClassifier(breaks, d3.schemeYlOrRd[breaks.length + 1])
                //d3.interpolateYlOrRd(Math.floor(20*c.sEMP / 100)/20)

                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    color: (c, r, z, viewScale) => empColorClassifier(c.sEMP),
                    size: (c, r, z, viewScale) => viewScale(c.T),
                    viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }),
                    shape: () => 'circle',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })
                gridLayer.styles = [style]

                gridLayer.minPixelsPerCell = 5



                //employment color legend
                style.legends.push(new gridviz.ColorDiscreteLegend({
                    title: "Employment, in %",
                    width: 250,
                    colors: () => empColorClassifier.colors,
                    breaks: () => empColorClassifier.breaks,
                }))

                //population size legend
                style.addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + d3.format('.1f')(c.sEMP) + ' %</b> employment<br>' +
                    //c.EMP + '<br>' +
                    (+c.F + +c.M) + ' person' + (+c.F + +c.M == 1 ? '' : 's')

            } else if (layCode === 'age') {

                const colAge = d3.interpolateSpectral
                const classNumberSize = 5
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            Y_LT15: colAge(0.2),
                            "Y15-64": colAge(0.4),
                            Y_GE65: colAge(0.9),
                        },
                        type: () => 'flag',
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 8, maxSizeFactor: 0.9 }),
                        //viewScale: gridviz.sizeScale({ valueFunction: (c) => +c.T, exponent: 0.1 }),
                        stripesOrientation: () => 90,
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                    ,
                ]

                gridLayer.minPixelsPerCell = 12

                //age
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Age",
                    colorLabel: [
                        [colAge(0.2), "Under 15 years"],
                        [colAge(0.4), "15 to 64 years"],
                        [colAge(0.9), "65 years and older"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        shape: "square",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65) + '</b> person' + ((+c.Y_LT15 + +c["Y15-64"] + +c.Y_GE65) == 1 ? '' : 's') + "<br>" +
                    c.Y_LT15 + " under 15 years<br>" +
                    c["Y15-64"] + " 15 to 64 years<br>" +
                    c.Y_GE65 + " 65 years and older"

            } else if (layCode === 'mobility') {

                const classNumberSize = 5
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            SAME: "#fed9a6", //light mostard
                            CHG_IN: "#7570b3", //blueish
                            CHG_OUT: "#d95f02", //orange
                        },
                        type: () => 'piechart', //flag, piechart, ring, segment, radar, agepyramid, halftone
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 6, maxSizeFactor: 1.1 }),
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                ]

                gridLayer.minPixelsPerCell = 12

                //mobility
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Mobility, compared to January 1, 2020",
                    colorLabel: [
                        ["#fed9a6", "Residence unchanged"],
                        ["#7570b3", "Moved within the country"],
                        ["#d95f02", "Moved from outside the country"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.SAME + +c.CHG_IN + +c.CHG_OUT) + '</b> person' + ((+c.SAME + +c.CHG_IN + +c.CHG_OUT) == 1 ? '' : 's') + "<br>" +
                    c.SAME + " residence unchanged<br>" +
                    c.CHG_IN + " moved within the country<br>" +
                    c.CHG_OUT + " moved from outside the country"

            } else if (layCode === 'pob') {

                const classNumberSize = 5
                gridLayer.styles = [
                    new gridviz.CompositionStyle({
                        color: {
                            NAT: "#fed9a6", //light mostard
                            EU_OTH: "#7570b3", //blueish
                            OTH: "#d95f02", //orange
                        },
                        type: () => 'halftone', //flag, piechart, ring, segment, radar, agepyramid, halftone
                        size: (c, r, z, scale) => scale(+c.T),
                        viewScale: gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 8 }),
                        blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                    })
                ]

                gridLayer.minPixelsPerCell = 12

                //place of birth
                gridLayer.styles[0].legends = [new gridviz.ColorCategoryLegend({
                    title: "Place of birth",
                    colorLabel: [
                        ["#fed9a6", "Born in the country"],
                        ["#7570b3", "Born in another EU member state"],
                        ["#d95f02", "Born outside the EU"],
                    ]
                })]

                //population
                gridLayer.styles[0].addLegends(
                    gridviz.sizeDiscreteViewScaleLegend(
                        classNumberSize, {
                        title: "Population",
                        fillColor: "lightgray",
                        labelFormat: Math.round,
                    })
                )

                gridLayer.cellInfoHTML = (c) => '<b>' + (+c.NAT + +c.EU_OTH + +c.OTH) + '</b> person' + ((+c.NAT + +c.EU_OTH + +c.OTH) == 1 ? '' : 's') + "<br>" +
                    c.NAT + " born in the country<br>" +
                    c.EU_OTH + " born in another EU member state<br>" +
                    c.OTH + " born outside the EU"

            } else if (layCode === 'share') {

                //get gui info
                const shareA = document.querySelector('#share_').value
                const shareB = "s" + shareA
                const sbtp = document.getElementById('sbtp').checked

                //define style

                //breaks
                let breaks = undefined
                switch (shareA) {
                    case 'F': breaks = [40, 45, 49, 50, 51, 55, 60]; break;
                    case 'M': breaks = [40, 45, 49, 50, 51, 55, 60]; break;
                    case 'Y_LT15': breaks = [5, 10, 15, 20, 30]; break;
                    case 'Y15-64': breaks = [50, 60, 65, 70, 80]; break;
                    case 'Y_GE65': breaks = [10, 20, 30, 40, 50]; break;
                    case 'EMP': breaks = [30, 40, 45, 50, 55, 60, 70]; break;
                    case 'SAME': breaks = [70, 80, 90, 95, 99]; break;
                    case 'CHG_IN': breaks = [0.1, 0.5, 1, 5, 10, 20]; break;
                    case 'CHG_OUT': breaks = [0.5, 1, 2, 5, 10]; break;
                    case 'NAT': breaks = [60, 70, 80, 85, 90, 95, 99]; break;
                    case 'EU_OTH': breaks = [1, 5, 10, 15, 20, 30]; break;
                    case 'OTH': breaks = [1, 5, 10, 20, 30, 50]; break;
                    default:
                        breaks = [30, 40, 45, 50, 55, 60, 70]
                }

                const classNumberColor = breaks.length + 1 //6
                const palette = shareA == 'M' || shareA == 'F' ? d3.schemeSpectral : d3.schemeYlOrRd
                const colors = palette[classNumberColor]
                const colorClassifier = gridviz.colorClassifier(breaks, colors)
                const classNumberSize = 4
                const style = new gridviz.ShapeColorSizeStyle({
                    filter: c => c[shareB] != undefined,
                    color: (c, r, z, viewScale) => colorClassifier(c[shareB]),
                    viewScale: sbtp ? gridviz.viewScaleQuantile({ valueFunction: (c) => +c.T, classNumber: classNumberSize, minSizePix: 3, maxSizeFactor: 1.1 }) : undefined,
                    size: sbtp ? (c, r, z, viewScale) => viewScale(c.T) : (c, r) => r,
                    shape: sbtp ? () => 'circle' : () => 'square',
                    blendOperation: (z) => z < 50 ? "multiply" : "source-over",
                })

                //set styles
                if (sbtp)
                    gridLayer.styles = [style]
                else
                    gridLayer.styles = [style, new gridviz.StrokeStyle({ visible: (z) => z < 50 })]

                //
                gridLayer.minPixelsPerCell = sbtp ? 5 : 1.5

                //share color legend
                style.addLegends([
                    new gridviz.ColorDiscreteLegend({
                        title: "Share of " + shareA + ", in %",
                        width: 250,
                        colors: () => colors,
                        breaks: () => breaks,
                    })
                ])

                //population size legend
                if (sbtp)
                    style.addLegends(
                        gridviz.sizeDiscreteViewScaleLegend(
                            classNumberSize, {
                            title: "Population",
                            fillColor: "lightgray",
                            labelFormat: Math.round,
                        })
                    )

                gridLayer.cellInfoHTML = (c) =>
                    '<b>' + d3.format('.1f')(c[shareB]) + ' %</b><br>' +
                    c[shareA] + '<br>' //+
                    + c.T + " person(s)"
                //(+c.F + +c.M) + ' person' + (+c.F + +c.M == 1 ? '' : 's')



            } else console.error('Unexpected layer code: ' + layCode)

            //redraw
            map.redraw()
        }


        //layer update
        document.querySelector('#layer').addEventListener('change', update)

        // show/hide labels
        document.querySelector('#label').addEventListener('change', function () {
            labelLayer.visible = () => this.checked
            map.redraw()
        })

        // show/hide boundaries
        document.querySelector('#boundary').addEventListener('change', function () {
            boundariesLayer.visible = () => this.checked
            map.redraw()
        })

        // show/hide background layer
        document.querySelector('#background').addEventListener('change', function () {
            if (this.checked) {
                backgroundLayer1.visible = (z) => z > 50
                backgroundLayer2.visible = (z) => z <= 50
            } else {
                backgroundLayer1.visible = () => false
                backgroundLayer2.visible = () => false
            }
            map.redraw()
        })

        //select layer from URL
        const ls = gridviz.getParameterByName('lay')
        if (ls) {
            const b = document.querySelector('#' + ls)
            if (b) b.checked = true
        }

        //initialise
        update()


    </script>
    <div style="
    position: absolute;
    right: 0px;
    bottom: 0px;
    width: auto;
    height: auto;
    padding: 1px;
    border: 0px;
    background: #ffffffcc;
">
        <span style="font-size: 0.8em">
            <a href="https://github.com/eurostat/gridviz" style="text-decoration: none">GridViz</a> |
            ©<a href="https://eurogeographics.org" style="text-decoration: none">EuroGeographics</a></span>
    </div>


</body>