<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: layers/points.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: layers/points.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// this file contains the logic for creating and updating threejs point layers (three.Points())
import {
    Points,
    Color,
    Float32BufferAttribute,
    BufferGeometry,
    ShaderMaterial,
    PointsMaterial
} from "three";
import * as CONSTANTS from "../constants.js";

/**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
function fragmentShader() {
    return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
}

/**
* @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
* @function vertexShader
*/
function vertexShader() {
    return `
      uniform float multiplier;
      attribute float size;
      float scale;
      varying vec3 vColor;
    
      void main() {
        vColor = color;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile &amp; desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers &amp; desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
}

/**
* @description create or update THREE.js viewer.pointsLayer layer. 
* At the moment, only ONE viewer.pointsLayer layer at a time is handled by the viewer, so a second call of gridviz.gridData() will overwrite the initial layer
* @function addPointsToScene
* @parameter points [{}]
*/
export function addPointsToScene(viewer, pointsArray) {
    //threejs recommends using BufferGeometry instead of Geometry for performance
    /*   indices = [0, 1, 2, 0, 2, 3];
  bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));  */
    if (!viewer.pointsGeometry) {
        viewer.pointsGeometry = new BufferGeometry();
    }

    let colors = [];
    let positions = [];
    let sizes = [];

    for (var i = 0; i &lt; pointsArray.length; i++) {
        // Set vector coordinates from data
        let coords = [
            pointsArray[i].x,
            pointsArray[i].y
        ];
        let x = parseFloat(coords[0]);
        let y = parseFloat(coords[1]);
        let z = CONSTANTS.point_z;
        let indicator = pointsArray[i][viewer.colorField_];
        let hex = viewer.colorScaleFunction_(parseFloat(indicator)); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);

        if (!isNaN(x) &amp;&amp; !isNaN(y)) {
            positions.push(x, y, z);
            if (!isNaN(color.r) &amp;&amp; !isNaN(color.g) &amp;&amp; !isNaN(color.b)) {
                colors.push(color.r, color.g, color.b);
            } else {
                let blk = new Color("#000");
                colors.push(blk.r, blk.g, blk.b)
            }
            if (viewer.sizeField_) {
                sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
            } else {
                sizes.push(viewer.pointSize);
            }
        }
    } //fin loop

    //set buffer geometry attributes
    viewer.pointsGeometry.setAttribute(
        "position",
        new Float32BufferAttribute(positions, 3)
    );
    viewer.pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    //Variable point size will affect raycasting: https://github.com/mrdoob/three.js/issues/5105
    viewer.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    viewer.pointsGeometry.computeBoundingSphere();
    //create or reuse viewer.pointsLayer Material
    if (!viewer.pointsMaterial) {
        // Apply custom point sizes, instead of using three.js pointsMaterial
        viewer.pointsMaterial = new ShaderMaterial({
            uniforms: {
                multiplier: {
                    value: 1000 + (50 * window.devicePixelRatio) //km TODO: define dynamically. This value needsto be adjusted according to screen in order prevent white lines across the screen flickering when zooming
                }
            },
            fragmentShader: fragmentShader(),
            vertexShader: vertexShader(),
            vertexColors: true
        });

        //use threejs PointsMaterial instead:
        // pointsMaterial = new PointsMaterial({
        //   size: gridConfig.pointSize * 2, // when using three.js attenuation we have to multiply the cellSize by 2
        //   sizeAttenuation: true,
        //   //https://github.com/mrdoob/three.js/blob/master/src/constants.js
        //   vertexColors: THREE.VertexColors
        // });

    } else {
        viewer.pointsMaterial.size = viewer.pointSize;
    }
    //create or overwrite viewer.pointsLayer object
    if (!viewer.pointsLayer) {
        viewer.pointsLayer = new Points(viewer.pointsGeometry, viewer.pointsMaterial);
        viewer.pointsLayer.renderOrder = 1; //bottom
        viewer.scene.add(viewer.pointsLayer);
    } else {
        viewer.pointsLayer.geometry = viewer.pointsGeometry;
        viewer.pointsLayer.material = viewer.pointsMaterial;
    }
}


/**
 * @description rebuilds array which stores point sizes
 * @function updatePointsSizes
 */
export function updatePointsSizes(viewer, pointsArray) {
    let sizes = [];
    for (var i = 0; i &lt; pointsArray.length; i++) {
        if (viewer.sizeField_ &amp;&amp; viewer.sizeField_ !== "null") {
            sizes.push(viewer.sizeScaleFunction_(pointsArray[i][viewer.sizeField_]));
        } else {
            sizes.push(viewer.pointSize);
        }
    }
    //update sizes
    pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = pointsGeometry;
}


/**
* @description rebuilds array of point colours
* @function updatePointsColors
*/
export function updatePointsColors(viewer, pointsArray) {
    let colors = [];
    for (var i = 0; i &lt; pointsArray.length; i++) {
        let hex = viewer.colorScaleFunction_(pointsArray[i][viewer.colorField_]); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);
        if (color) colors.push(color.r, color.g, color.b);
    }
    //update colors
    pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    pointsGeometry.computeBoundingSphere();
    viewer.pointsLayer.geometry = pointsGeometry;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addButtonEvents">addButtonEvents</a></li><li><a href="global.html#addChangeEventToColorFieldDropdown">addChangeEventToColorFieldDropdown</a></li><li><a href="global.html#addChangeEventToColorScaleDropdown">addChangeEventToColorScaleDropdown</a></li><li><a href="global.html#addChangeEventToColorSchemeDropdown">addChangeEventToColorSchemeDropdown</a></li><li><a href="global.html#addChangeEventToSizeFieldDropdown">addChangeEventToSizeFieldDropdown</a></li><li><a href="global.html#addEventListeners">addEventListeners</a></li><li><a href="global.html#addGeoJson">addGeoJson</a></li><li><a href="global.html#addGeoJsonToScene">addGeoJsonToScene</a></li><li><a href="global.html#addMouseEventsToView">addMouseEventsToView</a></li><li><a href="global.html#addNuts2jsonToScene">addNuts2jsonToScene</a></li><li><a href="global.html#addPanAndZoom">addPanAndZoom</a></li><li><a href="global.html#addPlacenamesToScene">addPlacenamesToScene</a></li><li><a href="global.html#addPointsToScene">addPointsToScene</a></li><li><a href="global.html#addResizeEvent">addResizeEvent</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#build">build</a></li><li><a href="global.html#colorLegend">colorLegend</a></li><li><a href="global.html#createCellsLegend">createCellsLegend</a></li><li><a href="global.html#createContinuousLegend">createContinuousLegend</a></li><li><a href="global.html#createLabelRenderer">createLabelRenderer</a></li><li><a href="global.html#createLegend">createLegend</a></li><li><a href="global.html#createLineFromCoords">createLineFromCoords</a></li><li><a href="global.html#createPlacenameLabelObject">createPlacenameLabelObject</a></li><li><a href="global.html#createRaycaster">createRaycaster</a></li><li><a href="global.html#createScene">createScene</a></li><li><a href="global.html#createTooltipContainer">createTooltipContainer</a></li><li><a href="global.html#createWebGLRenderer">createWebGLRenderer</a></li><li><a href="global.html#defineColorScale">defineColorScale</a></li><li><a href="global.html#defineDefaultPlacenameThresholds">defineDefaultPlacenameThresholds</a></li><li><a href="global.html#definePointSize">definePointSize</a></li><li><a href="global.html#defineRaycasterThreshold">defineRaycasterThreshold</a></li><li><a href="global.html#defineSizeScale">defineSizeScale</a></li><li><a href="global.html#defineWhereParameter">defineWhereParameter</a></li><li><a href="global.html#ensureTooltipOnScreen">ensureTooltipOnScreen</a></li><li><a href="global.html#fragmentShader">fragmentShader</a></li><li><a href="global.html#getPlacenames">getPlacenames</a></li><li><a href="global.html#getPopulationParameterFromScale">getPopulationParameterFromScale</a></li><li><a href="global.html#hideTooltip">hideTooltip</a></li><li><a href="global.html#loadGrid">loadGrid</a></li><li><a href="global.html#loadNuts2json">loadNuts2json</a></li><li><a href="global.html#onChangeColorField">onChangeColorField</a></li><li><a href="global.html#onChangeColorScale">onChangeColorScale</a></li><li><a href="global.html#onChangeColorScheme">onChangeColorScheme</a></li><li><a href="global.html#removePlacenamesFromScene">removePlacenamesFromScene</a></li><li><a href="global.html#requestGrid">requestGrid</a></li><li><a href="global.html#showTooltip">showTooltip</a></li><li><a href="global.html#thresholdLabels">thresholdLabels</a></li><li><a href="global.html#updateColorScaleFunction">updateColorScaleFunction</a></li><li><a href="global.html#updateLegend">updateLegend</a></li><li><a href="global.html#updatePointsColors">updatePointsColors</a></li><li><a href="global.html#updatePointsSizes">updatePointsSizes</a></li><li><a href="global.html#updateTooltip">updateTooltip</a></li><li><a href="global.html#validateInputs">validateInputs</a></li><li><a href="global.html#vertexShader">vertexShader</a></li><li><a href="global.html#viewer">viewer</a></li><li><a href="global.html#viewWholeGrid">viewWholeGrid</a></li><li><a href="global.html#zoom">zoom</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Thu Sep 23 2021 16:50:00 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
