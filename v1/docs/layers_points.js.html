<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: layers/points.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: layers/points.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// this file contains the logic for creating and updating threejs point layers (three.Points())
import {
    Points,
    Color,
    Float32BufferAttribute,
    BufferGeometry,
    ShaderMaterial,
    PointsMaterial,
    BoxBufferGeometry,
    MeshBasicMaterial,
    Object3D,
    Geometry,
    Mesh,
    Vector3
} from "three";
import * as CONSTANTS from "../constants.js";

/**
* @description WebGL - Shader stage that will process a Fragment generated by the Rasterization into a set of colors and a single depth value
* @function fragmentShader
*/
function fragmentShader() {
    return `
      varying vec3 vColor;
    
      void main() {
        gl_FragColor = vec4( vColor.rgb, 1.0 );
      }
    `;
}

/**
* @description WebGL - shader stage in the rendering pipeline that handles the processing of individual vertices
* @function vertexShader
*/
function vertexShader() {
    return `
      uniform float multiplier;
      attribute float size;
      float scale;
      varying vec3 vColor;
    
      void main() {
        vColor = color;
    
        // mvPosition represents the vertex position in view space (model-view-position). Itâ€™s usually calculated like so:
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    
        // manual 'point attenuation' attempt because threejs attenuation doesnt coincide with real world cellSize 
        // (e.g. 1000 for 1km grid leaves space between cells)...
        // this method works well on mobile &amp; desktop, but not when appending the renderer to a container
        gl_PointSize = size * (multiplier / -mvPosition.z ); 
    
        // threejs attenuation (attenuation: true in pointer material)...
        // does this: gl_PointSize *= ( scale / - mvPosition.z );
        // works well in containers &amp; desktop, but not mobile
        // gl_PointSize = size;
    
        //set position:
        gl_Position = projectionMatrix * mvPosition;
      }
    `;
}

/**
* @description create or update THREE.js app.pointsLayer layer. 
* At the moment, only ONE app.pointsLayer layer at a time is handled by the app, so a second call of gridviz.gridData() will overwrite the initial layer
* @function addPointsToScene
* @parameter app
* @parameter grid: config passed to addGrid()
* @parameter pointsArray [{}]
*/
export function addPointsToScene(app, grid, pointsArray) {


    if (app.cellShape_ == 'square') {
        //threejs recommends using BufferGeometry instead of Geometry for performance
        /*   indices = [0, 1, 2, 0, 2, 3];
      bufferGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));  */
        if (!app.pointsGeometry) {
            app.pointsGeometry = new BufferGeometry();
        }

        let colors = [];
        let positions = [];
        let sizes = [];

        for (var i = 0; i &lt; pointsArray.length; i++) {
            // Set vector coordinates from data
            let coords = [
                pointsArray[i].x,
                pointsArray[i].y
            ];
            let x = parseFloat(coords[0]);
            let y = parseFloat(coords[1]);
            let z = CONSTANTS.point_z;
            let indicator = pointsArray[i][grid.colorField];
            let hex = getCellColor(app, indicator);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);

            if (!isNaN(x) &amp;&amp; !isNaN(y)) {
                positions.push(x, y, z);
                if (!isNaN(color.r) &amp;&amp; !isNaN(color.g) &amp;&amp; !isNaN(color.b)) {
                    colors.push(color.r, color.g, color.b);
                } else {
                    let blk = new Color("#000");
                    colors.push(blk.r, blk.g, blk.b)
                }
                if (grid.sizeField) {
                    sizes.push(app.sizeScaleFunction_(pointsArray[i][grid.sizeField_]));
                } else {
                    sizes.push(grid.cellSize);
                }
            }
        } //fin loop

        //set buffer geometry attributes
        app.pointsGeometry.setAttribute(
            "position",
            new Float32BufferAttribute(positions, 3)
        );
        app.pointsGeometry.setAttribute(
            "color",
            new Float32BufferAttribute(colors, 3)
        );
        //Variable point size will affect raycasting: https://github.com/mrdoob/three.js/issues/5105
        app.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
        app.pointsGeometry.computeBoundingSphere();
        //create or reuse app.pointsLayer Material
        if (!app.pointsMaterial) {
            // Apply custom point sizes, instead of using three.js pointsMaterial
            app.pointsMaterial = new ShaderMaterial({
                uniforms: {
                    multiplier: {
                        value: 1000 //km TODO: define dynamically. This value needs to be adjusted according to screen in order prevent screen flickering when zooming
                    }
                },
                fragmentShader: fragmentShader(),
                vertexShader: vertexShader(),
                vertexColors: true
            });

            //use threejs PointsMaterial instead:
            // pointsMaterial = new PointsMaterial({
            //   size: grid.pointSize * 2, // when using three.js attenuation we have to multiply the cellSize by 2
            //   sizeAttenuation: true,
            //   //https://github.com/mrdoob/three.js/blob/master/src/constants.js
            //   vertexColors: THREE.VertexColors
            // });

        } else {
            app.pointsMaterial.size = grid.cellSize;
        }

        //create or overwrite app.pointsLayer object
        if (!app.pointsLayer) {
            app.pointsLayer = new Points(app.pointsGeometry, app.pointsMaterial);
            app.pointsLayer.renderOrder = 1; //bottom
            app.scene.add(app.pointsLayer);
        } else {
            //overwrite current la
            app.pointsLayer.geometry = app.pointsGeometry;
            app.pointsLayer.material = app.pointsMaterial;
        }

    } else if (app.cellShape_ == "bar") {

        // define bars object, geometry and material
        const bars = new Object3D();


        // create bar for each cell
        for (var i = 0; i &lt; pointsArray.length; i++) {
            let height;

            if (grid.sizeField) {
                height = app.sizeScaleFunction_(pointsArray[i][grid.sizeField]);
            } else {
                height = grid.cellSize;
            }

            let hex = getCellColor(app, pointsArray[i][grid.colorField]);
            pointsArray[i].color = hex; //save for tooltip
            let color = new Color(hex);
 
            let x = parseFloat(pointsArray[i].x);
            let y = parseFloat(pointsArray[i].y);
            
            const bar = getBar(x, y, grid.cellSize, grid.cellSize,height,color);
            bar.lookAt(new Vector3(x,y,0.0001));
            bars.add(bar);
        }

        // let x = 4369, y = 3230, z = 0.0001;
        // const bar = getBar(x, y, radius);
        // bar.lookAt(new Vector3(x,y,z));
        // bars.add(bar);

        // add bars to the app
        app.pointsLayer = bars;
        app.scene.add(bars);

    }

}

function getCellColor(app, value) {
    let hex = app.colorScaleFunction_(parseFloat(value)); //d3 scale-chromatic
    if (hex == "rgb(NaN, NaN, NaN)") {
        hex = "#000"; //fallback to black
    }
return hex;

}

function getBar(x, y,width,length, height, color) {


    const geometry = new BoxBufferGeometry(width,length, height);
    const material = new MeshBasicMaterial({ color: color });
    const bar = new Mesh(geometry, material);

    // const phi = (90 - lat) * Math.PI / 180;
    // const theta = (180 - lng) * Math.PI / 180;

    // bar.position.x = radius * Math.sin(phi) * Math.cos(theta);
    // bar.position.y = radius * Math.cos(phi);
    // bar.position.z = radius * Math.sin(phi) * Math.sin(theta);

    bar.position.x = x;
    bar.position.y = y;
    bar.position.z = 0.001 + (height/2);

    return bar;
}

/**
 * @description rebuilds array which stores point sizes
 * @function updatePointsSizes
 */
export function updatePointsSizes(app, pointsArray) {
    let sizes = [];
    for (var i = 0; i &lt; pointsArray.length; i++) {
        if (grid.sizeField &amp;&amp; grid.sizeField !== "null") {
            sizes.push(app.sizeScaleFunction_(pointsArray[i][grid.sizeField]));
        } else {
            sizes.push(app.currentResolution_);
        }
    }
    //update sizes
    app.pointsGeometry.setAttribute("size", new Float32BufferAttribute(sizes, 1));
    app.pointsGeometry.computeBoundingSphere();
    app.pointsLayer.geometry = app.pointsGeometry;
}


/**
* @description rebuilds array of point colours
* @function updatePointsColors
*/
export function updatePointsColors(app, pointsArray) {
    let colors = [];
    for (var i = 0; i &lt; pointsArray.length; i++) {
        let hex = app.colorScaleFunction_(pointsArray[i][grid.colorField]); //d3 scale-chromatic
        if (hex == "rgb(NaN, NaN, NaN)") {
            hex = "#000"; //fallback to black
        }
        pointsArray[i].color = hex; //for tooltip
        let color = new Color(hex);
        if (color) colors.push(color.r, color.g, color.b);
    }
    //update colors
    app.pointsGeometry.setAttribute(
        "color",
        new Float32BufferAttribute(colors, 3)
    );
    app.pointsGeometry.computeBoundingSphere();
    app.pointsLayer.geometry = app.pointsGeometry;
}


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addButtonEvents">addButtonEvents</a></li><li><a href="global.html#addChangeEventToColorFieldDropdown">addChangeEventToColorFieldDropdown</a></li><li><a href="global.html#addChangeEventToColorScaleDropdown">addChangeEventToColorScaleDropdown</a></li><li><a href="global.html#addChangeEventToColorSchemeDropdown">addChangeEventToColorSchemeDropdown</a></li><li><a href="global.html#addChangeEventToSizeFieldDropdown">addChangeEventToSizeFieldDropdown</a></li><li><a href="global.html#addEventListeners">addEventListeners</a></li><li><a href="global.html#addGeoJson">addGeoJson</a></li><li><a href="global.html#addGeoJsonToScene">addGeoJsonToScene</a></li><li><a href="global.html#addMouseEventsToView">addMouseEventsToView</a></li><li><a href="global.html#addPlacenamesToScene">addPlacenamesToScene</a></li><li><a href="global.html#addPointsToScene">addPointsToScene</a></li><li><a href="global.html#addResizeEvent">addResizeEvent</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#build">build</a></li><li><a href="global.html#colorLegend">colorLegend</a></li><li><a href="global.html#createCellsLegend">createCellsLegend</a></li><li><a href="global.html#createContinuousLegend">createContinuousLegend</a></li><li><a href="global.html#createLegend">createLegend</a></li><li><a href="global.html#createLineFromCoords">createLineFromCoords</a></li><li><a href="global.html#createPlacenameLabelObject">createPlacenameLabelObject</a></li><li><a href="global.html#createTooltipContainer">createTooltipContainer</a></li><li><a href="global.html#defineColorScale">defineColorScale</a></li><li><a href="global.html#defineDefaultPlacenameThresholds">defineDefaultPlacenameThresholds</a></li><li><a href="global.html#defineSizeScale">defineSizeScale</a></li><li><a href="global.html#defineWhereParameter">defineWhereParameter</a></li><li><a href="global.html#ensureTooltipOnScreen">ensureTooltipOnScreen</a></li><li><a href="global.html#fragmentShader">fragmentShader</a></li><li><a href="global.html#getPlacenames">getPlacenames</a></li><li><a href="global.html#getPopulationParameterFromScale">getPopulationParameterFromScale</a></li><li><a href="global.html#hideTooltip">hideTooltip</a></li><li><a href="global.html#loadGrid">loadGrid</a></li><li><a href="global.html#loadNuts2json">loadNuts2json</a></li><li><a href="global.html#onChangeColorField">onChangeColorField</a></li><li><a href="global.html#onChangeColorScale">onChangeColorScale</a></li><li><a href="global.html#onChangeColorScheme">onChangeColorScheme</a></li><li><a href="global.html#removePlacenamesFromScene">removePlacenamesFromScene</a></li><li><a href="global.html#requestGrid">requestGrid</a></li><li><a href="global.html#showTooltip">showTooltip</a></li><li><a href="global.html#thresholdLabels">thresholdLabels</a></li><li><a href="global.html#updateColorScaleFunction">updateColorScaleFunction</a></li><li><a href="global.html#updateLegend">updateLegend</a></li><li><a href="global.html#updatePointsColors">updatePointsColors</a></li><li><a href="global.html#updatePointsSizes">updatePointsSizes</a></li><li><a href="global.html#updateTooltip">updateTooltip</a></li><li><a href="global.html#vertexShader">vertexShader</a></li><li><a href="global.html#viewWholeGrid">viewWholeGrid</a></li><li><a href="global.html#zoom">zoom</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Fri Nov 26 2021 14:37:17 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
